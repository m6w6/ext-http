#!/usr/bin/env php
<?php

/**
 * The installer sub-stub for extension phars
 */

namespace pharext;

define("PHAREXT_PHAR", __FILE__);

spl_autoload_register(function($c) {
	return include strtr($c, "\\_", "//") . ".php";
});



namespace pharext;

class Exception extends \Exception
{
	public function __construct($message = null, $code = 0, $previous = null) {
		if (!isset($message)) {
			$last_error = error_get_last();
			$message = $last_error["message"];
			if (!$code) {
				$code = $last_error["type"];
			}
		}
		parent::__construct($message, $code, $previous);
	}
}



namespace pharext;

use pharext\Exception;

/**
 * A temporary file/directory name
 */
class Tempname
{
	/**
	 * @var string
	 */
	private $name;

	/**
	 * @param string $prefix uniqid() prefix
	 * @param string $suffix e.g. file extension
	 */
	public function __construct($prefix, $suffix = null) {
		$temp = sys_get_temp_dir() . "/pharext-" . $this->getUser();
		if (!is_dir($temp) && !mkdir($temp, 0700, true)) {
			throw new Exception;
		}
		$this->name = $temp ."/". uniqid($prefix) . $suffix;
	}

	private function getUser() {
		if (extension_loaded("posix") && function_exists("posix_getpwuid")) {
			return posix_getpwuid(posix_getuid())["name"];
		}
		return trim(`whoami 2>/dev/null`)
			?: trim(`id -nu 2>/dev/null`)
			?: getenv("USER")
			?: get_current_user();
	}

	/**
	 * @return string
	 */
	public function __toString() {
		return (string) $this->name;
	}
}

 

namespace pharext;

/**
 * Create a new temporary file
 */
class Tempfile extends \SplFileInfo
{
	/**
	 * @var resource
	 */
	private $handle;

	/**
	 * @param string $prefix uniqid() prefix
	 * @param string $suffix e.g. file extension
	 * @throws \pharext\Exception
	 */
	public function __construct($prefix, $suffix = ".tmp") {
		$tries = 0;
		$omask = umask(077);
		do {
			$path = new Tempname($prefix, $suffix);
			$this->handle = fopen($path, "x");
		} while (!is_resource($this->handle) && $tries++ < 10);
		umask($omask);
		
		if (!is_resource($this->handle)) {
			throw new Exception("Could not create temporary file");
		}
		
		parent::__construct($path);
	}

	/**
	 * Unlink the file
	 */
	public function __destruct() {
		if (is_file($this->getPathname())) {
			@unlink($this->getPathname());
		}
	}

	/**
	 * Close the stream
	 */
	public function closeStream() {
		fclose($this->handle);
	}

	/**
	 * Retrieve the stream resource
	 * @return resource
	 */
	public function getStream() {
		return $this->handle;
	}
}



namespace pharext;

/**
 * Create a temporary directory
 */
class Tempdir extends \SplFileInfo
{
	/**
	 * @param string $prefix prefix to uniqid()
	 * @throws \pharext\Exception
	 */
	public function __construct($prefix) {
		$temp = new Tempname($prefix);
		if (!is_dir($temp) && !mkdir($temp, 0700, true)) {
			throw new Exception("Could not create tempdir: ".error_get_last()["message"]);
		}
		parent::__construct($temp);
	}
}



namespace pharext;

use ArrayAccess;
use IteratorAggregate;
use RecursiveDirectoryIterator;
use SplFileInfo;

use pharext\Exception;

class Archive implements ArrayAccess, IteratorAggregate
{
	const HALT_COMPILER = "\137\137\150\141\154\164\137\143\157\155\160\151\154\145\162\50\51\73";
	const SIGNED = 0x10000;
	const SIG_MD5    = 0x0001;
	const SIG_SHA1   = 0x0002;
	const SIG_SHA256 = 0x0003;
	const SIG_SHA512 = 0x0004;
	const SIG_OPENSSL= 0x0010;

	private static $siglen = [
		self::SIG_MD5    => 16,
		self::SIG_SHA1   => 20,
		self::SIG_SHA256 => 32,
		self::SIG_SHA512 => 64,
		self::SIG_OPENSSL=> 0
	];

	private static $sigalg = [
		self::SIG_MD5    => "md5",
		self::SIG_SHA1   => "sha1",
		self::SIG_SHA256 => "sha256",
		self::SIG_SHA512 => "sha512",
		self::SIG_OPENSSL=> "openssl"
	];

	private static $sigtyp = [
		self::SIG_MD5    => "MD5",
		self::SIG_SHA1   => "SHA-1",
		self::SIG_SHA256 => "SHA-256",
		self::SIG_SHA512 => "SHA-512",
		self::SIG_OPENSSL=> "OpenSSL",
	];

	const PERM_FILE_MASK = 0x01ff;
	const COMP_FILE_MASK = 0xf000;
	const COMP_GZ_FILE   = 0x1000;
	const COMP_BZ2_FILE  = 0x2000;

	const COMP_PHAR_MASK= 0xf000;
	const COMP_PHAR_GZ  = 0x1000;
	const COMP_PHAR_BZ2 = 0x2000;

	private $file;
	private $fd;
	private $stub;
	private $manifest;
	private $signature;
	private $extracted;

	function __construct($file = null) {
		if (strlen($file)) {
			$this->open($file);
		}
	}

	function open($file) {
		if (!$this->fd = @fopen($file, "r")) {
			throw new Exception;
		}
		$this->file = $file;
		$this->stub = $this->readStub();
		$this->manifest = $this->readManifest();
		$this->signature = $this->readSignature();
	}

	function getIterator() {
		return new RecursiveDirectoryIterator($this->extract());
	}

	function extract() {
		return $this->extracted ?: $this->extractTo(new Tempdir("archive"));
	}

	function extractTo($dir) {
		if ((string) $this->extracted == (string) $dir) {
			return $this->extracted;
		}
		foreach ($this->manifest["entries"] as $file => $entry) {
			fseek($this->fd, $this->manifest["offset"]+$entry["offset"]);
			$path = "$dir/$file";
			$copy = stream_copy_to_stream($this->fd, $this->outFd($path, $entry["flags"]), $entry["csize"]);
			if ($entry["osize"] != $copy) {
				throw new Exception("Copied '$copy' of '$file', expected '{$entry["osize"]}' from '{$entry["csize"]}");
			}

			$crc = hexdec(hash_file("crc32b", $path));
			if ($crc !== $entry["crc32"]) {
				throw new Exception("CRC mismatch of '$file': '$crc' != '{$entry["crc32"]}");
			}

			chmod($path, $entry["flags"] & self::PERM_FILE_MASK);
			touch($path, $entry["stamp"]);
		}
		return $this->extracted = $dir;
	}

	function offsetExists($o) {
		return isset($this->entries[$o]);
	}

	function offsetGet($o) {
		$this->extract();
		return new SplFileInfo($this->extracted."/$o");
	}

	function offsetSet($o, $v) {
		throw new Exception("Archive is read-only");
	}

	function offsetUnset($o) {
		throw new Exception("Archive is read-only");
	}

	function getSignature() {
		/* compatible with Phar::getSignature() */
		return [
			"hash_type" => self::$sigtyp[$this->signature["flags"]],
			"hash" => strtoupper(bin2hex($this->signature["hash"])),
		];
	}

	function getPath() {
		/* compatible with Phar::getPath() */
		return new SplFileInfo($this->file);
	}

	function getMetadata($key = null) {
		if (isset($key)) {
			return $this->manifest["meta"][$key];
		}
		return $this->manifest["meta"];
	}

	private function outFd($path, $flags) {
			$dirn = dirname($path);
			if (!is_dir($dirn) && !@mkdir($dirn, 0777, true)) {
				throw new Exception;
			}
			if (!$fd = @fopen($path, "w")) {
				throw new Exception;
			}
			switch ($flags & self::COMP_FILE_MASK) {
			case self::COMP_GZ_FILE:
				if (!@stream_filter_append($fd, "zlib.inflate")) {
					throw new Exception;
				}
				break;
			case self::COMP_BZ2_FILE:
				if (!@stream_filter_append($fd, "bz2.decompress")) {
					throw new Exception;
				}
				break;
			}

	}
	private function readVerified($fd, $len) {
		if ($len != strlen($data = fread($fd, $len))) {
			throw new Exception("Unexpected EOF");
		}
		return $data;
	}

	private function readFormat($format, $fd, $len) {
		if (false === ($data = @unpack($format, $this->readVerified($fd, $len)))) {
			throw new Exception;
		}
		return $data;
	}

	private function readSingleFormat($format, $fd, $len) {
		return current($this->readFormat($format, $fd, $len));
	}

	private function readStringBinary($fd) {
		if (($length = $this->readSingleFormat("V", $fd, 4))) {
			return $this->readVerified($this->fd, $length);
		}
		return null;
	}

	private function readSerializedBinary($fd) {
		if (($length = $this->readSingleFormat("V", $fd, 4))) {
			if (false === ($data = unserialize($this->readVerified($fd, $length)))) {
				throw new Exception;
			}
			return $data;
		}
		return null;
	}

	private function readStub() {
		$stub = "";
		while (!feof($this->fd)) {
			$line = fgets($this->fd);
			$stub .= $line;
			if (false !== stripos($line, self::HALT_COMPILER)) {
				/* check for '?>' on a separate line */
				if ('?>' === $this->readVerified($this->fd, 2)) {
					$stub .= '?>' . fgets($this->fd);
				} else {
					fseek($this->fd, -2, SEEK_CUR);
				}
				break;
			}
		}
		return $stub;
	}

	private function readManifest() {
		$current = ftell($this->fd);
		$header = $this->readFormat("Vlen/Vnum/napi/Vflags", $this->fd, 14);
		$alias = $this->readStringBinary($this->fd);
		$meta = $this->readSerializedBinary($this->fd);
		$entries = [];
		for ($i = 0; $i < $header["num"]; ++$i) {
			$this->readEntry($entries);
		}
		$offset = ftell($this->fd);
		if (($length = $offset - $current - 4) != $header["len"]) {
			throw new Exception("Manifest length read was '$length', expected '{$header["len"]}'");
		}
		return $header + compact("alias", "meta", "entries", "offset");
	}

	private function readEntry(array &$entries) {
		if (!count($entries)) {
			$offset = 0;
		} else {
			$last = end($entries);
			$offset = $last["offset"] + $last["csize"];
		}
		$file = $this->readStringBinary($this->fd);
		if (!strlen($file)) {
			throw new Exception("Empty file name encountered at offset '$offset'");
		}
		$header = $this->readFormat("Vosize/Vstamp/Vcsize/Vcrc32/Vflags", $this->fd, 20);
		$meta = $this->readSerializedBinary($this->fd);
		$entries[$file] =  $header + compact("meta", "offset");
	}

	private function readSignature() {
		fseek($this->fd, -8, SEEK_END);
		$sig = $this->readFormat("Vflags/Z4magic", $this->fd, 8);
		$end = ftell($this->fd);

		if ($sig["magic"] !== "GBMB") {
			throw new Exception("Invalid signature magic value '{$sig["magic"]}");
		}

 		switch ($sig["flags"]) {
		case self::SIG_OPENSSL:
			fseek($this->fd, -12, SEEK_END);
			if (($hash = $this->readSingleFormat("V", $this->fd, 4))) {
				$offset = 4 + $hash;
				fseek($this->fd, -$offset, SEEK_CUR);
				$hash = $this->readVerified($this->fd, $hash);
				fseek($this->fd, 0, SEEK_SET);
				$valid = openssl_verify($this->readVerified($this->fd, $end - $offset - 8),
					$hash, @file_get_contents($this->file.".pubkey")) === 1;
			}
			break;

		case self::SIG_MD5:
		case self::SIG_SHA1:
		case self::SIG_SHA256:
		case self::SIG_SHA512:
			$offset = 8 + self::$siglen[$sig["flags"]];
			fseek($this->fd, -$offset, SEEK_END);
			$hash = $this->readVerified($this->fd, self::$siglen[$sig["flags"]]);
			$algo = hash_init(self::$sigalg[$sig["flags"]]);
			fseek($this->fd, 0, SEEK_SET);
			hash_update_stream($algo, $this->fd, $end - $offset);
			$valid = hash_final($algo, true) === $hash;
			break;

		default:
			throw new Exception("Invalid signature type '{$sig["flags"]}");
		}

		return $sig + compact("hash", "valid");
	}
}


namespace pharext;

if (extension_loaded("Phar")) {
	\Phar::interceptFileFuncs();
	\Phar::mapPhar();
	$phardir = "phar://".__FILE__;
} else {
	$archive = new Archive(__FILE__);
	$phardir = $archive->extract();
}

set_include_path("$phardir:". get_include_path());

$installer = new Installer();
$installer->run($argc, $argv);

__HALT_COMPILER(); ?>
D  H           )  a:7:{s:7:"version";s:5:"4.1.1";s:6:"header";s:49:"pharext v4.1.1 (c) Michael Wallner <mike@php.net>";s:4:"date";s:10:"2015-12-03";s:4:"name";s:5:"raphf";s:7:"release";s:6:"master";s:7:"license";s:1345:"Copyright (c) 2013, Michael Wallner <mike@php.net>.
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice, 
      this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright 
      notice, this list of conditions and the following disclaimer in the 
      documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE 
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
";s:4:"type";s:9:"extension";}   pharext/Archive.php  x9`V  4-‘I∂         pharext/Cli/Args/Help.php…  x9`V…  gX'∂         pharext/Cli/Args.php  x9`V  ?nùˆ∂         pharext/Cli/Command.phpk	  x9`Vk	  dÑaÍ∂         pharext/Command.php  x9`V  ‘m`Õ∂         pharext/Exception.phpc  x9`Vc  UÜœ{∂         pharext/ExecCmd.php  x9`V  πlî ∂         pharext/Installer.php&  x9`V&  ¯d&¿∂         pharext/License.phpì  x9`Vì  ÓÚE∂         pharext/Metadata.phpï  x9`Vï  ø⁄êû∂         pharext/Openssl/PrivateKey.php¡  x9`V¡  &ÊP∂         pharext/Packager.phpÃ!  x9`VÃ!  0<∂         pharext/SourceDir/Basic.phpz  x9`Vz  ˜+‘‚∂         pharext/SourceDir/Git.phpZ  x9`VZ  …Œ\∂         pharext/SourceDir/Pecl.php¯  x9`V¯  „˘–∂         pharext/SourceDir.phpΩ  x9`VΩ  3∑#∂         pharext/Task/Activate.php‹  x9`V‹  Iì∂         pharext/Task/Askpass.phpU  x9`VU  á*ê∂          pharext/Task/BundleGenerator.php}  x9`V}   Ô`Y∂         pharext/Task/Cleanup.php  x9`V  …IÄB∂         pharext/Task/Configure.phpT  x9`VT  }ÀÏ∂         pharext/Task/Extract.phpp  x9`Vp  [®€Ã∂         pharext/Task/GitClone.phpm  x9`Vm  Ûyµ@∂         pharext/Task/Make.php™  x9`V™  úÁ6∂         pharext/Task/PaxFixup.php¨  x9`V¨  y‚Ø∂         pharext/Task/PeclFixup.phpú  x9`Vú  e˘tö∂         pharext/Task/PharBuild.php‚  x9`V‚  Œ∂0…∂         pharext/Task/PharCompress.phpc  x9`Vc  Ω≥œ∂         pharext/Task/PharRename.php‰  x9`V‰  ä[ﬁÀ∂         pharext/Task/PharSign.php®  x9`V®  €∫¶i∂         pharext/Task/PharStub.phpÊ  x9`VÊ  Y|≠õ∂         pharext/Task/Phpize.php  x9`V  ˘2—∂         pharext/Task/StreamFetch.php  x9`V  àÓs\∂         pharext/Task.phpw   x9`Vw    ƒI«∂         pharext/Tempdir.phpµ  x9`Vµ  Îñ,∂         pharext/Tempfile.php  x9`V   ÆÙ∂         pharext/Tempname.phpt  x9`Vt  ûn<ç∂         pharext/Updater.phpç  x9`Vç  ûœv∂         pharext_installer.php›  x9`V›  åﬁq∂         pharext_packager.phpb  x9`Vb  ÓV”œ∂         pharext_updater.phph  x9`Vh    ˙j∂         .editorconfigL  x9`VL  ﬁç1∂         .gitattributesG   x9`VG   yñ∂      
   .gitignore  x9`V  }
I∂         .gitmodulesn   x9`Vn   •…NÇ∂         .travis.ymlı  x9`Vı  (@©D∂         AUTHORS   x9`V   \ƒH≠∂         BUGS*   x9`V*   <Ó∂         CONTRIBUTING.mdé  x9`Vé  ∂NÅq∂         CREDITS   x9`V   Cµ]≤∂         Doxyfile”,  x9`V”,  Mcæ‹∂         LICENSEA  x9`VA  æ¨J˛∂         Makefile.fragæ  x9`Væ  ›ØıØ∂      	   README.md  x9`V  ôÀ‹?∂         THANKSd   x9`Vd   ÃD"Â∂         TODO   x9`V   y_˜E∂      	   config.m4   x9`V   oÍdî∂      
   config.w32Ú  x9`VÚ  L˜fO∂      
   config0.m4Â  x9`VÂ  «◊Œb∂         package.xml.	  x9`V.	  Z-¡¸∂         php_raphf.h  x9`V  µò:é∂         php_raphf_test.cÕ  x9`VÕ  ∑f>x∂      	   raphf.png|p  x9`V|p  s‰ô≥∂         scripts/gen_travis_yml.php„  x9`V„  ÓÃŸˆ∂         src/php_raphf_api.cÅE  x9`VÅE  ôP∂         src/php_raphf_api.hf2  x9`Vf2  ”I}û∂         tests/http001.phpt  x9`V  *Æ∂         tests/http002.phptL  x9`VL  Ä‘ÔS∂         tests/http003.phpt^  x9`V^  àp∂         tests/http004.phpt[  x9`V[  YË´∂         tests/test.phptæ
  x9`Væ
  $‡ÌY∂         travis/pecl    x9`V        ∂      <?php

namespace pharext;

use ArrayAccess;
use IteratorAggregate;
use RecursiveDirectoryIterator;
use SplFileInfo;

use pharext\Exception;

class Archive implements ArrayAccess, IteratorAggregate
{
	const HALT_COMPILER = "\137\137\150\141\154\164\137\143\157\155\160\151\154\145\162\50\51\73";
	const SIGNED = 0x10000;
	const SIG_MD5    = 0x0001;
	const SIG_SHA1   = 0x0002;
	const SIG_SHA256 = 0x0003;
	const SIG_SHA512 = 0x0004;
	const SIG_OPENSSL= 0x0010;

	private static $siglen = [
		self::SIG_MD5    => 16,
		self::SIG_SHA1   => 20,
		self::SIG_SHA256 => 32,
		self::SIG_SHA512 => 64,
		self::SIG_OPENSSL=> 0
	];

	private static $sigalg = [
		self::SIG_MD5    => "md5",
		self::SIG_SHA1   => "sha1",
		self::SIG_SHA256 => "sha256",
		self::SIG_SHA512 => "sha512",
		self::SIG_OPENSSL=> "openssl"
	];

	private static $sigtyp = [
		self::SIG_MD5    => "MD5",
		self::SIG_SHA1   => "SHA-1",
		self::SIG_SHA256 => "SHA-256",
		self::SIG_SHA512 => "SHA-512",
		self::SIG_OPENSSL=> "OpenSSL",
	];

	const PERM_FILE_MASK = 0x01ff;
	const COMP_FILE_MASK = 0xf000;
	const COMP_GZ_FILE   = 0x1000;
	const COMP_BZ2_FILE  = 0x2000;

	const COMP_PHAR_MASK= 0xf000;
	const COMP_PHAR_GZ  = 0x1000;
	const COMP_PHAR_BZ2 = 0x2000;

	private $file;
	private $fd;
	private $stub;
	private $manifest;
	private $signature;
	private $extracted;

	function __construct($file = null) {
		if (strlen($file)) {
			$this->open($file);
		}
	}

	function open($file) {
		if (!$this->fd = @fopen($file, "r")) {
			throw new Exception;
		}
		$this->file = $file;
		$this->stub = $this->readStub();
		$this->manifest = $this->readManifest();
		$this->signature = $this->readSignature();
	}

	function getIterator() {
		return new RecursiveDirectoryIterator($this->extract());
	}

	function extract() {
		return $this->extracted ?: $this->extractTo(new Tempdir("archive"));
	}

	function extractTo($dir) {
		if ((string) $this->extracted == (string) $dir) {
			return $this->extracted;
		}
		foreach ($this->manifest["entries"] as $file => $entry) {
			fseek($this->fd, $this->manifest["offset"]+$entry["offset"]);
			$path = "$dir/$file";
			$copy = stream_copy_to_stream($this->fd, $this->outFd($path, $entry["flags"]), $entry["csize"]);
			if ($entry["osize"] != $copy) {
				throw new Exception("Copied '$copy' of '$file', expected '{$entry["osize"]}' from '{$entry["csize"]}");
			}

			$crc = hexdec(hash_file("crc32b", $path));
			if ($crc !== $entry["crc32"]) {
				throw new Exception("CRC mismatch of '$file': '$crc' != '{$entry["crc32"]}");
			}

			chmod($path, $entry["flags"] & self::PERM_FILE_MASK);
			touch($path, $entry["stamp"]);
		}
		return $this->extracted = $dir;
	}

	function offsetExists($o) {
		return isset($this->entries[$o]);
	}

	function offsetGet($o) {
		$this->extract();
		return new SplFileInfo($this->extracted."/$o");
	}

	function offsetSet($o, $v) {
		throw new Exception("Archive is read-only");
	}

	function offsetUnset($o) {
		throw new Exception("Archive is read-only");
	}

	function getSignature() {
		/* compatible with Phar::getSignature() */
		return [
			"hash_type" => self::$sigtyp[$this->signature["flags"]],
			"hash" => strtoupper(bin2hex($this->signature["hash"])),
		];
	}

	function getPath() {
		/* compatible with Phar::getPath() */
		return new SplFileInfo($this->file);
	}

	function getMetadata($key = null) {
		if (isset($key)) {
			return $this->manifest["meta"][$key];
		}
		return $this->manifest["meta"];
	}

	private function outFd($path, $flags) {
			$dirn = dirname($path);
			if (!is_dir($dirn) && !@mkdir($dirn, 0777, true)) {
				throw new Exception;
			}
			if (!$fd = @fopen($path, "w")) {
				throw new Exception;
			}
			switch ($flags & self::COMP_FILE_MASK) {
			case self::COMP_GZ_FILE:
				if (!@stream_filter_append($fd, "zlib.inflate")) {
					throw new Exception;
				}
				break;
			case self::COMP_BZ2_FILE:
				if (!@stream_filter_append($fd, "bz2.decompress")) {
					throw new Exception;
				}
				break;
			}

	}
	private function readVerified($fd, $len) {
		if ($len != strlen($data = fread($fd, $len))) {
			throw new Exception("Unexpected EOF");
		}
		return $data;
	}

	private function readFormat($format, $fd, $len) {
		if (false === ($data = @unpack($format, $this->readVerified($fd, $len)))) {
			throw new Exception;
		}
		return $data;
	}

	private function readSingleFormat($format, $fd, $len) {
		return current($this->readFormat($format, $fd, $len));
	}

	private function readStringBinary($fd) {
		if (($length = $this->readSingleFormat("V", $fd, 4))) {
			return $this->readVerified($this->fd, $length);
		}
		return null;
	}

	private function readSerializedBinary($fd) {
		if (($length = $this->readSingleFormat("V", $fd, 4))) {
			if (false === ($data = unserialize($this->readVerified($fd, $length)))) {
				throw new Exception;
			}
			return $data;
		}
		return null;
	}

	private function readStub() {
		$stub = "";
		while (!feof($this->fd)) {
			$line = fgets($this->fd);
			$stub .= $line;
			if (false !== stripos($line, self::HALT_COMPILER)) {
				/* check for '?>' on a separate line */
				if ('?>' === $this->readVerified($this->fd, 2)) {
					$stub .= '?>' . fgets($this->fd);
				} else {
					fseek($this->fd, -2, SEEK_CUR);
				}
				break;
			}
		}
		return $stub;
	}

	private function readManifest() {
		$current = ftell($this->fd);
		$header = $this->readFormat("Vlen/Vnum/napi/Vflags", $this->fd, 14);
		$alias = $this->readStringBinary($this->fd);
		$meta = $this->readSerializedBinary($this->fd);
		$entries = [];
		for ($i = 0; $i < $header["num"]; ++$i) {
			$this->readEntry($entries);
		}
		$offset = ftell($this->fd);
		if (($length = $offset - $current - 4) != $header["len"]) {
			throw new Exception("Manifest length read was '$length', expected '{$header["len"]}'");
		}
		return $header + compact("alias", "meta", "entries", "offset");
	}

	private function readEntry(array &$entries) {
		if (!count($entries)) {
			$offset = 0;
		} else {
			$last = end($entries);
			$offset = $last["offset"] + $last["csize"];
		}
		$file = $this->readStringBinary($this->fd);
		if (!strlen($file)) {
			throw new Exception("Empty file name encountered at offset '$offset'");
		}
		$header = $this->readFormat("Vosize/Vstamp/Vcsize/Vcrc32/Vflags", $this->fd, 20);
		$meta = $this->readSerializedBinary($this->fd);
		$entries[$file] =  $header + compact("meta", "offset");
	}

	private function readSignature() {
		fseek($this->fd, -8, SEEK_END);
		$sig = $this->readFormat("Vflags/Z4magic", $this->fd, 8);
		$end = ftell($this->fd);

		if ($sig["magic"] !== "GBMB") {
			throw new Exception("Invalid signature magic value '{$sig["magic"]}");
		}

 		switch ($sig["flags"]) {
		case self::SIG_OPENSSL:
			fseek($this->fd, -12, SEEK_END);
			if (($hash = $this->readSingleFormat("V", $this->fd, 4))) {
				$offset = 4 + $hash;
				fseek($this->fd, -$offset, SEEK_CUR);
				$hash = $this->readVerified($this->fd, $hash);
				fseek($this->fd, 0, SEEK_SET);
				$valid = openssl_verify($this->readVerified($this->fd, $end - $offset - 8),
					$hash, @file_get_contents($this->file.".pubkey")) === 1;
			}
			break;

		case self::SIG_MD5:
		case self::SIG_SHA1:
		case self::SIG_SHA256:
		case self::SIG_SHA512:
			$offset = 8 + self::$siglen[$sig["flags"]];
			fseek($this->fd, -$offset, SEEK_END);
			$hash = $this->readVerified($this->fd, self::$siglen[$sig["flags"]]);
			$algo = hash_init(self::$sigalg[$sig["flags"]]);
			fseek($this->fd, 0, SEEK_SET);
			hash_update_stream($algo, $this->fd, $end - $offset);
			$valid = hash_final($algo, true) === $hash;
			break;

		default:
			throw new Exception("Invalid signature type '{$sig["flags"]}");
		}

		return $sig + compact("hash", "valid");
	}
}
<?php

namespace pharext\Cli\Args;

use pharext\Cli\Args;

class Help
{
	private $args;

	function __construct($prog, Args $args) {
		$this->prog = $prog;
		$this->args = $args;
	}

	function __toString() {
		$usage = "Usage:\n\n  \$ ";
		$usage .= $this->prog;

		list($flags, $required, $optional, $positional) = $this->listSpec();
		if ($flags) {
			$usage .= $this->dumpFlags($flags);
		}
		if ($required) {
			$usage .= $this->dumpRequired($required);
		}
		if ($optional) {
			$usage .= $this->dumpOptional($optional);
		}
		if ($positional) {
			$usage .= $this->dumpPositional($positional);
		}

		$help = $this->dumpHelp($positional);

		return $usage . "\n\n" . $help . "\n";
	}

	function listSpec() {
		$flags = [];
		$required = [];
		$optional = [];
		$positional = [];
		foreach ($this->args->getSpec() as $spec) {
			if (is_numeric($spec[0])) {
				$positional[] = $spec;
			} elseif ($spec[3] & Args::REQUIRED) {
				$required[] = $spec;
			} elseif ($spec[3] & (Args::OPTARG|Args::REQARG)) {
				$optional[] = $spec;
			} else {
				$flags[] = $spec;
			}
		}

		return [$flags, $required, $optional, $positional]
			+ compact("flags", "required", "optional", "positional");
	}

	function dumpFlags(array $flags) {
		return sprintf(" [-%s]", implode("", array_column($flags, 0)));
	}

	function dumpRequired(array $required) {
		$dump = "";
		foreach ($required as $req) {
			$dump .= sprintf(" -%s <%s>", $req[0], $req[1]);
		}
		return $dump;
	}

	function dumpOptional(array $optional) {
		$req = array_filter($optional, function($a) {
			return $a[3] & Args::REQARG;
		});
		$opt = array_filter($optional, function($a) {
			return $a[3] & Args::OPTARG;
		});

		$dump = "";
		if ($req) {
			$dump .= sprintf(" [-%s <arg>]", implode("|-", array_column($req, 0)));
		}
		if ($opt) {
			$dump .= sprintf(" [-%s [<arg>]]", implode("|-", array_column($opt, 0)));
		}
		return $dump;
	}

	function dumpPositional(array $positional) {
		$dump = " [--]";
		foreach ($positional as $pos) {
			if ($pos[3] & Args::REQUIRED) {
				$dump .= sprintf(" <%s>", $pos[1]);
			} else {
				$dump .= sprintf(" [<%s>]", $pos[1]);
			}
			if ($pos[3] & Args::MULTI) {
				$dump .= sprintf(" [<%s>]...", $pos[1]);
			}
		}
		return $dump;
	}

	function calcMaxLen() {
		$spc = $this->args->getSpec();
		$max = max(array_map("strlen", array_column($spc, 1)));
		$max += $max % 8 + 2;
		return $max;
	}

	function dumpHelp() {
		$max = $this->calcMaxLen();
		$dump = "";
		foreach ($this->args->getSpec() as $spec) {
			$dump .= "    ";
			if (is_numeric($spec[0])) {
				$dump .= sprintf("--   %s ", $spec[1]);
			} elseif (isset($spec[0])) {
				$dump .= sprintf("-%s|", $spec[0]);
			}
			if (!is_numeric($spec[0])) {
				$dump .= sprintf("--%s ", $spec[1]);
			}
			if ($spec[3] & Args::REQARG) {
				$dump .= "<arg>  ";
			} elseif ($spec[3] & Args::OPTARG) {
				$dump .= "[<arg>]";
			} else {
				$dump .= "       ";
			}

			$dump .= str_repeat(" ", $max-strlen($spec[1])+3*!isset($spec[0]));
			$dump .= $spec[2];

			if ($spec[3] & Args::REQUIRED) {
				$dump .= " (REQUIRED)";
			}
			if ($spec[3] & Args::MULTI) {
				$dump .= " (MULTIPLE)";
			}
			if (isset($spec[4])) {
				$dump .= sprintf(" [%s]", $spec[4]);
			}
			$dump .= "\n";
		}
		return $dump;
	}
}
<?php

namespace pharext\Cli;

/**
 * Command line arguments
 */
class Args implements \ArrayAccess
{
	/**
	 * Optional option
	 */
	const OPTIONAL = 0x000;

	/**
	 * Required Option
	 */
	const REQUIRED = 0x001;

	/**
	 * Only one value, even when used multiple times
	 */
	const SINGLE = 0x000;

	/**
	 * Aggregate an array, when used multiple times
	 */
	const MULTI = 0x010;

	/**
	 * Option takes no argument
	 */
	const NOARG = 0x000;

	/**
	 * Option requires an argument
	 */
	const REQARG = 0x100;

	/**
	 * Option takes an optional argument
	 */
	const OPTARG = 0x200;

	/**
	 * Option halts processing
	 */
	const HALT = 0x10000000;

	/**
	 * Original option spec
	 * @var array
	 */
	private $orig = [];

	/**
	 * Compiled spec
	 * @var array
	 */
	private $spec = [];

	/**
	 * Parsed args
	 * @var array
	 */
	private $args = [];

	/**
	 * Compile the original spec
	 * @param array|Traversable $spec
	 */
	public function __construct($spec = null) {
		if (is_array($spec) || $spec instanceof Traversable) {
			$this->compile($spec);
		}

	}

	/**
	 * Compile the original spec
	 * @param array|Traversable $spec
	 * @return pharext\Cli\Args self
	 */
	public function compile($spec) {
		foreach ($spec as $arg) {
			if (isset($arg[0]) && is_numeric($arg[0])) {
				$arg[3] &= ~0xf00;
				$this->spec["--".$arg[0]] = $arg;
			} elseif (isset($arg[0])) {
				$this->spec["-".$arg[0]] = $arg;
				$this->spec["--".$arg[1]] = $arg;
			} else {
				$this->spec["--".$arg[1]] = $arg;
			}
			$this->orig[] = $arg;
		}
		return $this;
	}

	/**
	 * Get original spec
	 * @return array
	 */
	public function getSpec() {
		return $this->orig;
	}

	/**
	 * Get compiled spec
	 * @return array
	 */
	public function getCompiledSpec() {
		return $this->spec;
	}

	/**
	 * Parse command line arguments according to the compiled spec.
	 *
	 * The Generator yields any parsing errors.
	 * Parsing will stop when all arguments are processed or the first option
	 * flagged Cli\Args::HALT was encountered.
	 *
	 * @param int $argc
	 * @param array $argv
	 * @return Generator
	 */
	public function parse($argc, array $argv) {
		for ($f = false, $p = 0, $i = 0; $i < $argc; ++$i) {
			$o = $argv[$i];

			if ($o{0} === "-" && strlen($o) > 2 && $o{1} !== "-") {
				// multiple short opts, e.g. -vps
				$argc += strlen($o) - 2;
				array_splice($argv, $i, 1, array_map(function($s) {
					return "-$s";
				}, str_split(substr($o, 1))));
				$o = $argv[$i];
			} elseif ($o{0} === "-" && strlen($o) > 2 && $o{1} === "-" && 0 < ($eq = strpos($o, "="))) {
				// long opt with argument, e.g. --foo=bar
				$argc++;
				array_splice($argv, $i, 1, [
					substr($o, 0, $eq++),
					substr($o, $eq)
				]);
				$o = $argv[$i];
			} elseif ($o === "--") {
				// only positional args following
				$f = true;
				continue;
			}

			if ($f || !isset($this->spec[$o])) {
				if ($o{0} !== "-" && isset($this->spec["--$p"])) {
					$this[$p] = $o;
					if (!$this->optIsMulti($p)) {
						++$p;
					}
				} else {
					yield sprintf("Unknown option %s", $o);
				}
			} elseif (!$this->optAcceptsArg($o)) {
				$this[$o] = true;
			} elseif ($i+1 < $argc && !isset($this->spec[$argv[$i+1]])) {
				$this[$o] = $argv[++$i];
			} elseif ($this->optRequiresArg($o)) {
				yield sprintf("Option --%s requires an argument", $this->optLongName($o));
			} else {
				// OPTARG
				$this[$o] = $this->optDefaultArg($o);
			}

			if ($this->optHalts($o)) {
				return;
			}
		}
	}

	/**
	 * Validate that all required options were given.
	 *
	 * The Generator yields any validation errors.
	 *
	 * @return Generator
	 */
	public function validate() {
		$required = array_filter($this->orig, function($spec) {
			return $spec[3] & self::REQUIRED;
		});
		foreach ($required as $req) {
			if ($req[3] & self::MULTI) {
				if (is_array($this[$req[0]])) {
					continue;
				}
			} elseif (strlen($this[$req[0]])) {
				continue;
			}
			if (is_numeric($req[0])) {
				yield sprintf("Argument <%s> is required", $req[1]);
			} else {
				yield sprintf("Option --%s is required", $req[1]);
			}
		}
	}


	public function toArray() {
		$args = [];
		foreach ($this->spec as $spec) {
			$opt = $this->opt($spec[1]);
			$args[$opt] = $this[$opt];
		}
		return $args;
	}

	/**
	 * Retreive the default argument of an option
	 * @param string $o
	 * @return mixed
	 */
	private function optDefaultArg($o) {
		$o = $this->opt($o);
		if (isset($this->spec[$o][4])) {
			return $this->spec[$o][4];
		}
		return null;
	}

	/**
	 * Retrieve the help message of an option
	 * @param string $o
	 * @return string
	 */
	private function optHelp($o) {
		$o = $this->opt($o);
		if (isset($this->spec[$o][2])) {
			return $this->spec[$o][2];
		}
		return "";
	}

	/**
	 * Retrieve option's flags
	 * @param string $o
	 * @return int
	 */
	private function optFlags($o) {
		$o = $this->opt($o);
		if (isset($this->spec[$o])) {
			return $this->spec[$o][3];
		}
		return null;
	}

	/**
	 * Check whether an option is flagged for halting argument processing
	 * @param string $o
	 * @return boolean
	 */
	private function optHalts($o) {
		return $this->optFlags($o) & self::HALT;
	}

	/**
	 * Check whether an option needs an argument
	 * @param string $o
	 * @return boolean
	 */
	private function optRequiresArg($o) {
		return $this->optFlags($o) & self::REQARG;
	}

	/**
	 * Check wether an option accepts any argument
	 * @param string $o
	 * @return boolean
	 */
	private function optAcceptsArg($o) {
		return $this->optFlags($o) & 0xf00;
	}

	/**
	 * Check whether an option can be used more than once
	 * @param string $o
	 * @return boolean
	 */
	private function optIsMulti($o) {
		return $this->optFlags($o) & self::MULTI;
	}

	/**
	 * Retreive the long name of an option
	 * @param string $o
	 * @return string
	 */
	private function optLongName($o) {
		$o = $this->opt($o);
		return is_numeric($this->spec[$o][0]) ? $this->spec[$o][0] : $this->spec[$o][1];
	}

	/**
	 * Retreive the short name of an option
	 * @param string $o
	 * @return string
	 */
	private function optShortName($o) {
		$o = $this->opt($o);
		return is_numeric($this->spec[$o][0]) ? null : $this->spec[$o][0];
	}

	/**
	 * Retreive the canonical name (--long-name) of an option
	 * @param string $o
	 * @return string
	 */
	private function opt($o) {
		if (is_numeric($o)) {
			return "--$o";
		}
		if ($o{0} !== '-') {
			if (strlen($o) > 1) {
				$o = "-$o";
			}
			$o = "-$o";
		}
		return $o;
	}

	/**@+
	 * Implements ArrayAccess and virtual properties
	 */
	function offsetExists($o) {
		$o = $this->opt($o);
		return isset($this->args[$o]);
	}
	function __isset($o) {
		return $this->offsetExists($o);
	}
	function offsetGet($o) {
		$o = $this->opt($o);
		if (isset($this->args[$o])) {
			return $this->args[$o];
		}
		return $this->optDefaultArg($o);
	}
	function __get($o) {
		return $this->offsetGet($o);
	}
	function offsetSet($o, $v) {
		$osn = $this->optShortName($o);
		$oln = $this->optLongName($o);
		if ($this->optIsMulti($o)) {
			if (isset($osn)) {
				$this->args["-$osn"][] = $v;
			}
			$this->args["--$oln"][] = $v;
		} else {
			if (isset($osn)) {
				$this->args["-$osn"] = $v;
			}
			$this->args["--$oln"] = $v;
		}
	}
	function __set($o, $v) {
		$this->offsetSet($o, $v);
	}
	function offsetUnset($o) {
		unset($this->args["-".$this->optShortName($o)]);
		unset($this->args["--".$this->optLongName($o)]);
	}
	function __unset($o) {
		$this->offsetUnset($o);
	}
	/**@-*/
}
<?php

namespace pharext\Cli;

use pharext\Archive;

use Phar;

trait Command
{
	/**
	 * Command line arguments
	 * @var pharext\Cli\Args
	 */
	private $args;
	
	/**
	 * @inheritdoc
	 * @see \pharext\Command::getArgs()
	 */
	public function getArgs() {
		return $this->args;
	}

	/**
	 * Retrieve metadata of the currently running phar
	 * @param string $key
	 * @return mixed
	 */
	public function metadata($key = null) {
		if (extension_loaded("Phar")) {
			$running = new Phar(Phar::running(false));
		} else {
			$running = new Archive(PHAREXT_PHAR);
		}

		if ($key === "signature") {
			$sig = $running->getSignature();
			return sprintf("%s signature of %s\n%s", 
				$sig["hash_type"],
				$this->metadata("name"),
				chunk_split($sig["hash"], 64, "\n"));
		}

		$metadata = $running->getMetadata();
		if (isset($key)) {
			return $metadata[$key];
		}
		return $metadata;
	}

	/**
	 * Output pharext vX.Y.Z header
	 */
	public function header() {
		if (!headers_sent()) {
			/* only display header, if we didn't generate any output yet */
			printf("%s\n\n", $this->metadata("header"));
		}
	}
	
	/**
	 * @inheritdoc
	 * @see \pharext\Command::debug()
	 */
	public function debug($fmt) {
		if ($this->args->verbose) {
			vprintf($fmt, array_slice(func_get_args(), 1));
		}
	}
	
	/**
	 * @inheritdoc
	 * @see \pharext\Command::info()
	 */
	public function info($fmt) {
		if (!$this->args->quiet) {
			vprintf($fmt, array_slice(func_get_args(), 1));
		}
	}

	/**
	 * @inheritdoc
	 * @see \pharext\Command::warn()
	 */
	public function warn($fmt) {
		if (!$this->args->quiet) {
			if (!isset($fmt)) {
				$fmt = "%s\n";
				$arg = error_get_last()["message"];
			} else {
				$arg = array_slice(func_get_args(), 1);
			}
			vfprintf(STDERR, "Warning: $fmt", $arg);
		}
	}

	/**
	 * @inheritdoc
	 * @see \pharext\Command::error()
	 */
	public function error($fmt) {
		if (!isset($fmt)) {
			$fmt = "%s\n";
			$arg = error_get_last()["message"];
		} else {
			$arg = array_slice(func_get_args(), 1);
		}
		vfprintf(STDERR, "ERROR: $fmt", $arg);
	}

	/**
	 * Output command line help message
	 * @param string $prog
	 */
	public function help($prog) {
		print new Args\Help($prog, $this->args);
	}
	
	/**
	 * Verbosity
	 * @return boolean
	 */
	public function verbosity() {
		if ($this->args->verbose) {
			return true;
		} elseif ($this->args->quiet) {
			return false;
		} else {
			return null;
		}
	}
}
<?php

namespace pharext;

/**
 * Command interface
 */
interface Command
{
	/**
	 * Argument error
	 */
	const EARGS = 1;
	/**
	 * Build error
	 */
	const EBUILD = 2;
	/**
	 * Signature error
	 */
	const ESIGN = 3;
	/**
	 * Extract/unpack error
	 */
	const EEXTRACT = 4;
	/**
	 * Install error
	 */
	const EINSTALL = 5;
	
	/**
	 * Retrieve command line arguments
	 * @return pharext\Cli\Args
	 */
	public function getArgs();
	
	/**
	 * Print debug message
	 * @param string $fmt
	 * @param string ...$args
	 */
	public function debug($fmt);
	
	/**
	 * Print info
	 * @param string $fmt
	 * @param string ...$args
	 */
	public function info($fmt);
	
	/**
	 * Print warning
	 * @param string $fmt
	 * @param string ...$args
	 */
	public function warn($fmt);

	/**
	 * Print error
	 * @param string $fmt
	 * @param string ...$args
	 */
	public function error($fmt);

	/**
	 * Execute the command
	 * @param int $argc command line argument count
	 * @param array $argv command line argument list
	 */
	public function run($argc, array $argv);
}
<?php

namespace pharext;

class Exception extends \Exception
{
	public function __construct($message = null, $code = 0, $previous = null) {
		if (!isset($message)) {
			$last_error = error_get_last();
			$message = $last_error["message"];
			if (!$code) {
				$code = $last_error["type"];
			}
		}
		parent::__construct($message, $code, $previous);
	}
}
<?php

namespace pharext;

/**
 * Execute system command
 */
class ExecCmd
{
	/**
	 * Sudo command, if the cmd needs escalated privileges
	 * @var string
	 */
	private $sudo;
	
	/**
	 * Executable of the cmd
	 * @var string
	 */
	private $command;
	
	/**
	 * Passthrough cmd output
	 * @var bool
	 */
	private $verbose;
	
	/**
	 * Output of cmd run
	 * @var string
	 */
	private $output;
	
	/**
	 * Return code of cmd run
	 * @var int
	 */
	private $status;

	/**
	 * @param string $command
	 * @param bool verbose
	 */
	public function __construct($command, $verbose = false) {
		$this->command = $command;
		$this->verbose = $verbose;
	}
	
	/**
	 * (Re-)set sudo command
	 * @param string $sudo
	 */
	public function setSu($sudo = false) {
		$this->sudo = $sudo;
	}
	
	/**
	 * Execute a program with escalated privileges handling interactive password prompt
	 * @param string $command
	 * @param bool $verbose
	 * @return int exit status
	 */
	private function suExec($command, $verbose = null) {
		if (!($proc = proc_open($command, [STDIN,["pipe","w"],["pipe","w"]], $pipes))) {
			$this->status = -1;
			throw new Exception("Failed to run {$command}");
		}
		
		$stdout = $pipes[1];
		$passwd = 0;
		$checks = 10;

		while (!feof($stdout)) {
			$R = [$stdout]; $W = []; $E = [];
			if (!stream_select($R, $W, $E, null)) {
				continue;
			}
			$data = fread($stdout, 0x1000);
			/* only check a few times */
			if ($passwd < $checks) {
				$passwd++;
				if (stristr($data, "password")) {
					$passwd = $checks + 1;
					printf("\n%s", $data);
					continue;
				}
			} elseif ($passwd > $checks) {
				/* new line after pw entry */
				printf("\n");
				$passwd = $checks;
			}
			
			if ($verbose === null) {
				print $this->progress($data, 0);
			} else {
				if ($verbose) {
					printf("%s", $data);
				}
				$this->output .= $data;
			}
		}
		if ($verbose === null) {
			$this->progress("", PHP_OUTPUT_HANDLER_FINAL);
		}
		return $this->status = proc_close($proc);
	}

	/**
	 * Output handler that displays some progress while soaking output
	 * @param string $string
	 * @param int $flags
	 * @return string
	 */
	private function progress($string, $flags) {
		static $counter = 0;
		static $symbols = ["\\","|","/","-"];

		$this->output .= $string;
		
		if (false !== strpos($string, "\n")) {
			++$counter;
		}

		return $flags & PHP_OUTPUT_HANDLER_FINAL
			? "   \r"
			: sprintf("  %s\r", $symbols[$counter % 4]);
	}

	/**
	 * Run the command
	 * @param array $args
	 * @return \pharext\ExecCmd self
	 * @throws \pharext\Exception
	 */
	public function run(array $args = null) {
		$exec = escapeshellcmd($this->command);
		if ($args) {
			$exec .= " ". implode(" ", array_map("escapeshellarg", (array) $args));
		}
		
		if ($this->sudo) {
			$this->suExec(sprintf($this->sudo." 2>&1", $exec), $this->verbose);
		} elseif ($this->verbose) {
			ob_start(function($s) {
				$this->output .= $s;
				return $s;
			}, 1);
			passthru($exec, $this->status);
			ob_end_flush();
		} elseif ($this->verbose !== false /* !quiet */) {
			ob_start([$this, "progress"], 1);
			passthru($exec . " 2>&1", $this->status);
			ob_end_flush();
		} else {
			exec($exec ." 2>&1", $output, $this->status);
			$this->output = implode("\n", $output);
		}
		
		if ($this->status) {
			throw new Exception("Command {$exec} failed ({$this->status})");
		}

		return $this;
	}
	
	/**
	 * Retrieve exit code of cmd run
	 * @return int
	 */
	public function getStatus() {
		return $this->status;
	}
	
	/**
	 * Retrieve output of cmd run
	 * @return string
	 */
	public function getOutput() {
		return $this->output;
	}
}
<?php

namespace pharext;

use Phar;
use SplObjectStorage;

/**
 * The extension install command executed by the extension phar
 */
class Installer implements Command
{
	use Cli\Command;

	/**
	 * Cleanups
	 * @var array
	 */
	private $cleanup = [];

	/**
	 * Create the command
	 */
	public function __construct() {
		$this->args = new Cli\Args([
			["h", "help", "Display help",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::NOARG|Cli\Args::HALT],
			["v", "verbose", "More output",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::NOARG],
			["q", "quiet", "Less output",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::NOARG],
			["p", "prefix", "PHP installation prefix if phpize is not in \$PATH, e.g. /opt/php7",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::REQARG],
			["n", "common-name", "PHP common program name, e.g. php5 or zts-php",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::REQARG,
				"php"],
			["c", "configure", "Additional extension configure flags, e.g. -c --with-flag",
				Cli\Args::OPTIONAL|Cli\Args::MULTI|Cli\Args::REQARG],
			["s", "sudo", "Installation might need increased privileges",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::OPTARG,
				"sudo -S %s"],
			["i", "ini", "Activate in this php.ini instead of loaded default php.ini",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::REQARG],
			[null, "signature", "Show package signature",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::NOARG|Cli\Args::HALT],
			[null, "license", "Show package license",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::NOARG|Cli\Args::HALT],
			[null, "name", "Show package name",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::NOARG|Cli\Args::HALT],
			[null, "date", "Show package release date",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::NOARG|Cli\Args::HALT],
			[null, "release", "Show package release version",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::NOARG|Cli\Args::HALT],
			[null, "version", "Show pharext version",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::NOARG|Cli\Args::HALT],
		]);
	}

	/**
	 * Perform cleaniup
	 */
	function __destruct() {
		foreach ($this->cleanup as $cleanup) {
			$cleanup->run();
		}
	}

	private function extract($phar) {
		$temp = (new Task\Extract($phar))->run($this->verbosity());
		$this->cleanup[] = new Task\Cleanup($temp);
		return $temp;
	}

	private function hooks(SplObjectStorage $phars) {
		$hook = [];
		foreach ($phars as $phar) {
			if (isset($phar["pharext_package.php"])) {
				$sdir = include $phar["pharext_package.php"];
				if ($sdir instanceof SourceDir) {
					$this->args->compile($sdir->getArgs());
					$hook[] = $sdir;
				}
			}
		}
		return $hook;
	}

	private function load() {
		$list = new SplObjectStorage();
		$phar = extension_loaded("Phar")
			? new Phar(Phar::running(false))
			: new Archive(PHAREXT_PHAR);
		$temp = $this->extract($phar);

		foreach ($phar as $entry) {
			$dep_file = $entry->getBaseName();
			if (fnmatch("*.ext.phar*", $dep_file)) {
				$dep_phar = extension_loaded("Phar")
					? new Phar("$temp/$dep_file")
					: new Archive("$temp/$dep_file");
				$list[$dep_phar] = $this->extract($dep_phar);
			}
		}

		/* the actual ext.phar at last */
		$list[$phar] = $temp;
		return $list;
	}

	/**
	 * @inheritdoc
	 * @see \pharext\Command::run()
	 */
	public function run($argc, array $argv) {
		try {
			/* load the phar(s) */
			$list = $this->load();
			/* installer hooks */
			$hook = $this->hooks($list);
		} catch (\Exception $e) {
			$this->error("%s\n", $e->getMessage());
			exit(self::EEXTRACT);
		}

		/* standard arg stuff */
		$errs = [];
		$prog = array_shift($argv);
		foreach ($this->args->parse(--$argc, $argv) as $error) {
			$errs[] = $error;
		}

		if ($this->args["help"]) {
			$this->header();
			$this->help($prog);
			exit;
		}
		try {
			foreach (["signature", "name", "date", "license", "release", "version"] as $opt) {
				if ($this->args[$opt]) {
					printf("%s\n", $this->metadata($opt));
					exit;
				}
			}
		} catch (\Exception $e) {
			$this->error("%s\n", $e->getMessage());
			exit(self::EARGS);
		}

		foreach ($this->args->validate() as $error) {
			$errs[] = $error;
		}

		if ($errs) {
			if (!$this->args["quiet"]) {
				$this->header();
			}
			foreach ($errs as $err) {
				$this->error("%s\n", $err);
			}
			if (!$this->args["quiet"]) {
				$this->help($prog);
			}
			exit(self::EARGS);
		}

		try {
			/* post process hooks */
			foreach ($hook as $sdir) {
				$sdir->setArgs($this->args);
			}
		} catch (\Exception $e) {
			$this->error("%s\n", $e->getMessage());
			exit(self::EARGS);
		}

		/* install packages */
		try {
			foreach ($list as $phar) {
				$this->info("Installing %s ...\n", basename($phar->getPath()));
				$this->install($list[$phar]);
				$this->activate($list[$phar]);
				$this->info("Successfully installed %s!\n", basename($phar->getPath()));
			}
		} catch (\Exception $e) {
			$this->error("%s\n", $e->getMessage());
			exit(self::EINSTALL);
		}
	}

	/**
	 * Phpize + trinity
	 */
	private function install($temp) {
		// phpize
		$phpize = new Task\Phpize($temp, $this->args->prefix, $this->args->{"common-name"});
		$phpize->run($this->verbosity());

		// configure
		$configure = new Task\Configure($temp, $this->args->configure, $this->args->prefix, $this->args->{"common-name"});
		$configure->run($this->verbosity());

		// make
		$make = new Task\Make($temp);
		$make->run($this->verbosity());

		// install
		$sudo = isset($this->args->sudo) ? $this->args->sudo : null;
		$install = new Task\Make($temp, ["install"], $sudo);
		$install->run($this->verbosity());
	}

	private function activate($temp) {
		if ($this->args->ini) {
			$files = [$this->args->ini];
		} else {
			$files = array_filter(array_map("trim", explode(",", php_ini_scanned_files())));
			$files[] = php_ini_loaded_file();
		}

		$sudo = isset($this->args->sudo) ? $this->args->sudo : null;
		$type = $this->metadata("type") ?: "extension";

		$activate = new Task\Activate($temp, $files, $type, $this->args->prefix, $this->args{"common-name"}, $sudo);
		if (!$activate->run($this->verbosity())) {
			$this->info("Extension already activated ...\n");
		}
	}
}
<?php

namespace pharext;

trait License
{
	function findLicense($dir, $file = null) {
		if (isset($file)) {
			return realpath("$dir/$file");
		}

		$names = [];
		foreach (["{,UN}LICEN{S,C}{E,ING}", "COPY{,ING,RIGHT}"] as $name) {
			$names[] = $this->mergeLicensePattern($name, strtolower($name));
		}
		$exts = [];
		foreach (["t{,e}xt", "rst", "asc{,i,ii}", "m{,ark}d{,own}", "htm{,l}"] as $ext) {
			$exts[] = $this->mergeLicensePattern(strtoupper($ext), $ext);
		}
		
		$pattern = "{". implode(",", $names) ."}{,.{". implode(",", $exts) ."}}";

		if (($glob = glob("$dir/$pattern", GLOB_BRACE))) {
			return current($glob);
		}
	}

	private function mergeLicensePattern($upper, $lower) {
		$pattern = "";
		$length = strlen($upper);
		for ($i = 0; $i < $length; ++$i) {
			if ($lower{$i} === $upper{$i}) {
				$pattern .= $upper{$i};
			} else {
				$pattern .= "[" . $upper{$i} . $lower{$i} . "]";
			}
		}
		return $pattern;
	}

	public function readLicense($file) {
		$text = file_get_contents($file);
		switch (strtolower(pathinfo($file, PATHINFO_EXTENSION))) {
			case "htm":
			case "html":
				$text = strip_tags($text);
				break;
		}
		return $text;
	}
}
<?php

namespace pharext;

class Metadata
{
	static function version() {
		return "4.1.1";
	}

	static function header() {
		return sprintf("pharext v%s (c) Michael Wallner <mike@php.net>", self::version());
	}

	static function date() {
		return gmdate("Y-m-d");
	}

	static function all() {
		return [
			"version" => self::version(),
			"header" => self::header(),
			"date" => self::date(),
		];
	}
}
<?php

namespace pharext\Openssl;

use pharext\Exception;

class PrivateKey
{
	/**
	 * Private key
	 * @var string
	 */
	private $key;
	
	/**
	 * Public key
	 * @var string
	 */
	private $pub;

	/**
	 * Read a private key
	 * @param string $file
	 * @param string $password
	 * @throws \pharext\Exception
	 */
	function __construct($file, $password) {
		/* there appears to be a bug with refcount handling of this
		 * resource; when the resource is stored as property, it cannot be
		 * "coerced to a private key" on openssl_sign() later in another method
		 */
		$key = openssl_pkey_get_private("file://$file", $password);
		if (!is_resource($key)) {
			throw new Exception("Could not load private key");
		}
		openssl_pkey_export($key, $this->key);
		$this->pub = openssl_pkey_get_details($key)["key"];
	}

	/**
	 * Sign the PHAR
	 * @param \Phar $package
	 */
	function sign(\Phar $package) {
		$package->setSignatureAlgorithm(\Phar::OPENSSL, $this->key);
	}

	/**
	 * Export the public key to a file
	 * @param string $file
	 * @throws \pharext\Exception
	 */
	function exportPublicKey($file) {
		if (!file_put_contents("$file.tmp", $this->pub) || !rename("$file.tmp", $file)) {
			throw new Exception;
		}
	}
}
<?php

namespace pharext;

use Phar;
use pharext\Exception;

/**
 * The extension packaging command executed by bin/pharext
 */
class Packager implements Command
{
	use Cli\Command;
	
	/**
	 * Extension source directory
	 * @var pharext\SourceDir
	 */
	private $source;
	
	/**
	 * Cleanups
	 * @var array
	 */
	private $cleanup = [];
	
	/**
	 * Create the command
	 */
	public function __construct() {
		$this->args = new Cli\Args([
			["h", "help", "Display this help",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::NOARG|Cli\Args::HALT],
			["v", "verbose", "More output",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::NOARG],
			["q", "quiet", "Less output",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::NOARG],
			["n", "name", "Extension name",
				Cli\Args::REQUIRED|Cli\Args::SINGLE|Cli\Args::REQARG],
			["r", "release", "Extension release version",
				Cli\Args::REQUIRED|Cli\Args::SINGLE|Cli\Args::REQARG],
			["s", "source", "Extension source directory",
				Cli\Args::REQUIRED|Cli\Args::SINGLE|Cli\Args::REQARG],
			["g", "git", "Use `git ls-tree` to determine file list",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::NOARG],
			["b", "branch", "Checkout this tag/branch",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::REQARG],
			["p", "pecl", "Use PECL package.xml to determine file list, name and release",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::NOARG],
			["d", "dest", "Destination directory",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::REQARG,
				"."],
			["z", "gzip", "Create additional PHAR compressed with gzip",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::NOARG],
			["Z", "bzip", "Create additional PHAR compressed with bzip",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::NOARG],
			["S", "sign", "Sign the PHAR with a private key",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::REQARG],
			["E", "zend", "Mark as Zend Extension",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::NOARG],
			[null, "signature", "Show pharext signature",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::NOARG|Cli\Args::HALT],
			[null, "license", "Show pharext license",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::NOARG|Cli\Args::HALT],
			[null, "version", "Show pharext version",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::NOARG|Cli\Args::HALT],
		]);
	}
	
	/**
	 * Perform cleaniup
	 */
	function __destruct() {
		foreach ($this->cleanup as $cleanup) {
			$cleanup->run();
		}
	}
	
	/**
	 * @inheritdoc
	 * @see \pharext\Command::run()
	 */
	public function run($argc, array $argv) {
		$errs = [];
		$prog = array_shift($argv);
		foreach ($this->args->parse(--$argc, $argv) as $error) {
			$errs[] = $error;
		}
		
		if ($this->args["help"]) {
			$this->header();
			$this->help($prog);
			exit;
		}
		try {
			foreach (["signature", "license", "version"] as $opt) {
				if ($this->args[$opt]) {
					printf("%s\n", $this->metadata($opt));
					exit;
				}
			}
		} catch (\Exception $e) {
			$this->error("%s\n", $e->getMessage());
			exit(self::EARGS);
		}

		try {
			/* source needs to be evaluated before Cli\Args validation, 
			 * so e.g. name and version can be overriden and Cli\Args 
			 * does not complain about missing arguments
			 */
			$this->loadSource();
		} catch (\Exception $e) {
			$errs[] = $e->getMessage();
		}
		
		foreach ($this->args->validate() as $error) {
			$errs[] = $error;
		}
		
		if ($errs) {
			if (!$this->args["quiet"]) {
				$this->header();
			}
			foreach ($errs as $err) {
				$this->error("%s\n", $err);
			}
			printf("\n");
			if (!$this->args["quiet"]) {
				$this->help($prog);
			}
			exit(self::EARGS);
		}
		
		$this->createPackage();
	}
	
	/**
	 * Download remote source
	 * @param string $source
	 * @return string local source
	 */
	private function download($source) {
		if ($this->args->git) {
			$task = new Task\GitClone($source, $this->args->branch);
		} else {
			/* print newline only once */
			$done = false;
			$task = new Task\StreamFetch($source, function($bytes_pct) use(&$done) {
				if (!$done) {
					$this->info(" %3d%% [%s>%s] \r",
						floor($bytes_pct*100),
						str_repeat("=", round(50*$bytes_pct)),
						str_repeat(" ", round(50*(1-$bytes_pct)))
					);
					if ($bytes_pct == 1) {
						$done = true;
						$this->info("\n");
					}
				}
			});
		}
		$local = $task->run($this->verbosity());

		$this->cleanup[] = new Task\Cleanup($local);
		return $local;
	}

	/**
	 * Extract local archive
	 * @param stirng $source
	 * @return string extracted directory
	 */
	private function extract($source) {
		try {
			$task = new Task\Extract($source);
			$dest = $task->run($this->verbosity());
		} catch (\Exception $e) {
			if (false === strpos($e->getMessage(), "checksum mismatch")) {
				throw $e;
			}
			$dest = (new Task\PaxFixup($source))->run($this->verbosity());
		}
		
		$this->cleanup[] = new Task\Cleanup($dest);
		return $dest;
	}

	/**
	 * Localize a possibly remote source
	 * @param string $source
	 * @return string local source directory
	 */
	private function localize($source) {
		if (!stream_is_local($source) || ($this->args->git && isset($this->args->branch))) {
			$source = $this->download($source);
			$this->cleanup[] = new Task\Cleanup($source);
		}
		$source = realpath($source);
		if (!is_dir($source)) {
			$source = $this->extract($source);
			$this->cleanup[] = new Task\Cleanup($source);
			
			if (!$this->args->git) {
				$source = (new Task\PeclFixup($source))->run($this->verbosity());
			}
		}
		return $source;
	}

	/**
	 * Load the source dir
	 * @throws \pharext\Exception
	 */
	private function loadSource(){
		if ($this->args["source"]) {
			$source = $this->localize($this->args["source"]);

			if ($this->args["pecl"]) {
				$this->source = new SourceDir\Pecl($source);
			} elseif ($this->args["git"]) {
				$this->source = new SourceDir\Git($source);
			} elseif (is_file("$source/pharext_package.php")) {
				$this->source = include "$source/pharext_package.php";
			} else {
				$this->source = new SourceDir\Basic($source);
			}

			if (!$this->source instanceof SourceDir) {
				throw new Exception("Unknown source dir $source");
			}

			foreach ($this->source->getPackageInfo() as $key => $val) {
				$this->args->$key = $val;
			}
		}
	}

	/**
	 * Creates the extension phar
	 */
	private function createPackage() {
		try {
			$meta = array_merge(Metadata::all(), [
				"name" => $this->args->name,
				"release" => $this->args->release,
				"license" => $this->source->getLicense(),
				"type" => $this->args->zend ? "zend_extension" : "extension",
			]);
			$file = (new Task\PharBuild($this->source, __DIR__."/../pharext_installer.php", $meta))->run($this->verbosity());
		} catch (\Exception $e) {
			$this->error("%s\n", $e->getMessage());
			exit(self::EBUILD);
		}

		try {
			if ($this->args->sign) {
				$this->info("Using private key to sign phar ...\n");
				$pass = (new Task\Askpass)->run($this->verbosity());
				$sign = new Task\PharSign($file, $this->args->sign, $pass);
				$pkey = $sign->run($this->verbosity());
			}

		} catch (\Exception $e) {
			$this->error("%s\n", $e->getMessage());
			exit(self::ESIGN);
		}

		if ($this->args->gzip) {
			try {
				$gzip = (new Task\PharCompress($file, Phar::GZ))->run();
				$move = new Task\PharRename($gzip, $this->args->dest, $this->args->name ."-". $this->args->release);
				$name = $move->run($this->verbosity());

				$this->info("Created gzipped phar %s\n", $name);

				if ($this->args->sign) {
					$sign = new Task\PharSign($name, $this->args->sign, $pass);
					$sign->run($this->verbosity())->exportPublicKey($name.".pubkey");
				}

			} catch (\Exception $e) {
				$this->warn("%s\n", $e->getMessage());
			}
		}
		
		if ($this->args->bzip) {
			try {
				$bzip = (new Task\PharCompress($file, Phar::BZ2))->run();
				$move = new Task\PharRename($bzip, $this->args->dest, $this->args->name ."-". $this->args->release);
				$name = $move->run($this->verbosity());

				$this->info("Created bzipped phar %s\n", $name);

				if ($this->args->sign) {
					$sign = new Task\PharSign($name, $this->args->sign, $pass);
					$sign->run($this->verbosity())->exportPublicKey($name.".pubkey");
				}

			} catch (\Exception $e) {
				$this->warn("%s\n", $e->getMessage());
			}
		}

		try {
			$move = new Task\PharRename($file, $this->args->dest, $this->args->name ."-". $this->args->release);
			$name = $move->run($this->verbosity());

			$this->info("Created executable phar %s\n", $name);

			if (isset($pkey)) {
				$pkey->exportPublicKey($name.".pubkey");
			}

		} catch (\Exception $e) {
			$this->error("%s\n", $e->getMessage());
			exit(self::EBUILD);
		}
	}
}
<?php

namespace pharext\SourceDir;

use pharext\Cli\Args;
use pharext\License;
use pharext\SourceDir;

use FilesystemIterator;
use IteratorAggregate;
use RecursiveCallbackFilterIterator;
use RecursiveDirectoryIterator;
use RecursiveIteratorIterator;


class Basic implements IteratorAggregate, SourceDir
{
	use License;
	
	private $path;
	
	public function __construct($path) {
		$this->path = $path;
	}
	
	public function getBaseDir() {
		return $this->path;
	}
	
	public function getPackageInfo() {
		return [];
	}
	
	public function getLicense() {
		if (($file = $this->findLicense($this->getBaseDir()))) {
			return $this->readLicense($file);
		}
		return "UNKNOWN";
	}

	public function getArgs() {
		return [];
	}
	
	public function setArgs(Args $args) {
	}

	public function filter($current, $key, $iterator) {
		$sub = $current->getSubPath();
		if ($sub === ".git" || $sub === ".hg" || $sub === ".svn") {
			return false;
		}
		return true;
	}
	
	public function getIterator() {
		$rdi = new RecursiveDirectoryIterator($this->path,
				FilesystemIterator::CURRENT_AS_SELF | // needed for 5.5
				FilesystemIterator::KEY_AS_PATHNAME |
				FilesystemIterator::SKIP_DOTS);
		$rci = new RecursiveCallbackFilterIterator($rdi, [$this, "filter"]);
		$rii = new RecursiveIteratorIterator($rci);
		foreach ($rii as $path => $child) {
			if (!$child->isDir()) {
				yield realpath($path);
			}
		}
	}
}
<?php

namespace pharext\SourceDir;

use pharext\Cli\Args;
use pharext\License;
use pharext\SourceDir;

/**
 * Extension source directory which is a git repo
 */
class Git implements \IteratorAggregate, SourceDir
{
	use License;
	
	/**
	 * Base directory
	 * @var string
	 */
	private $path;
	
	/**
	 * @inheritdoc
	 * @see \pharext\SourceDir::__construct()
	 */
	public function __construct($path) {
		$this->path = $path;
	}

	/**
	 * @inheritdoc
	 * @see \pharext\SourceDir::getBaseDir()
	 */
	public function getBaseDir() {
		return $this->path;
	}

	/**
	 * @inheritdoc
	 * @return array
	 */
	public function getPackageInfo() {
		return [];
	}

	/**
	 * @inheritdoc
	 * @return string
	 */
	public function getLicense() {
		if (($file = $this->findLicense($this->getBaseDir()))) {
			return $this->readLicense($file);
		}
		return "UNKNOWN";
	}

	/**
	 * @inheritdoc
	 * @return array
	 */
	public function getArgs() {
		return [];
	}

	/**
	 * @inheritdoc
	 */
	public function setArgs(Args $args) {
	}

	/**
	 * Generate a list of files by `git ls-files`
	 * @return Generator
	 */
	private function generateFiles() {
		$pwd = getcwd();
		chdir($this->path);
		if (($pipe = popen("git ls-tree -r --name-only HEAD", "r"))) {
			$path = realpath($this->path);
			while (!feof($pipe)) {
				if (strlen($file = trim(fgets($pipe)))) {
					/* there may be symlinks, so no realpath here */
					yield "$path/$file";
				}
			}
			pclose($pipe);
		}
		chdir($pwd);
	}

	/**
	 * Implements IteratorAggregate
	 * @see IteratorAggregate::getIterator()
	 */
	public function getIterator() {
		return $this->generateFiles();
	}
}
<?php

namespace pharext\SourceDir;

use pharext\Cli\Args;
use pharext\Exception;
use pharext\SourceDir;
use pharext\License;

/**
 * A PECL extension source directory containing a v2 package.xml
 */
class Pecl implements \IteratorAggregate, SourceDir
{
	use License;
	
	/**
	 * The package.xml
	 * @var SimpleXmlElement
	 */
	private $sxe;
	
	/**
	 * The base directory
	 * @var string
	 */
	private $path;

	/**
	 * The package.xml
	 * @var string
	 */
	private $file;
	
	/**
	 * @inheritdoc
	 * @see \pharext\SourceDir::__construct()
	 */
	public function __construct($path) {
		if (is_file("$path/package2.xml")) {
			$sxe = simplexml_load_file($this->file = "$path/package2.xml");
		} elseif (is_file("$path/package.xml")) {
			$sxe = simplexml_load_file($this->file = "$path/package.xml");
		} else {
			throw new Exception("Missing package.xml in $path");
		}
		
		$sxe->registerXPathNamespace("pecl", $sxe->getDocNamespaces()[""]);
		
		$this->sxe = $sxe;
		$this->path = realpath($path);
	}
	
	/**
	 * @inheritdoc
	 * @see \pharext\SourceDir::getBaseDir()
	 */
	public function getBaseDir() {
		return $this->path;
	}

	/**
	 * Retrieve gathered package info
	 * @return Generator
	 */
	public function getPackageInfo() {
		if (($name = $this->sxe->xpath("/pecl:package/pecl:name"))) {
			yield "name" => (string) $name[0];
		}
		if (($release = $this->sxe->xpath("/pecl:package/pecl:version/pecl:release"))) {
			yield "release" => (string) $release[0];
		}
		if ($this->sxe->xpath("/pecl:package/pecl:zendextsrcrelease")) {
			yield "zend" => true;
		}
	}

	/**
	 * @inheritdoc
	 * @return string
	 */
	public function getLicense() {
		if (($license = $this->sxe->xpath("/pecl:package/pecl:license"))) {
			if (($file = $this->findLicense($this->getBaseDir(), $license[0]["filesource"]))) {
				return $this->readLicense($file);
			}
		}
		if (($file = $this->findLicense($this->getBaseDir()))) {
			return $this->readLicense($file);
		}
		if ($license) {
			return $license[0] ." ". $license[0]["uri"];
		}
		return "UNKNOWN";
	}

	/**
	 * @inheritdoc
	 * @see \pharext\SourceDir::getArgs()
	 */
	public function getArgs() {
		$configure = $this->sxe->xpath("/pecl:package/pecl:extsrcrelease/pecl:configureoption");
		foreach ($configure as $cfg) {
			yield [null, $cfg["name"], ucfirst($cfg["prompt"]), Args::OPTARG,
				strlen($cfg["default"]) ? $cfg["default"] : null];
		}
		$configure = $this->sxe->xpath("/pecl:package/pecl:zendextsrcrelease/pecl:configureoption");
		foreach ($configure as $cfg) {
			yield [null, $cfg["name"], ucfirst($cfg["prompt"]), Args::OPTARG,
				strlen($cfg["default"]) ? $cfg["default"] : null];
		}
	}

	/**
	 * @inheritdoc
	 * @see \pharext\SourceDir::setArgs()
	 */
	public function setArgs(Args $args) {
		$configure = $this->sxe->xpath("/pecl:package/pecl:extsrcrelease/pecl:configureoption");
		foreach ($configure as $cfg) {
			if (isset($args[$cfg["name"]])) {
				$args->configure = "--{$cfg["name"]}={$args[$cfg["name"]]}";
			}
		}
		$configure = $this->sxe->xpath("/pecl:package/pecl:zendextsrcrelease/pecl:configureoption");
		foreach ($configure as $cfg) {
			if (isset($args[$cfg["name"]])) {
				$args->configure = "--{$cfg["name"]}={$args[$cfg["name"]]}";
			}
		}
	}
	
	/**
	 * Compute the path of a file by parent dir nodes
	 * @param \SimpleXMLElement $ele
	 * @return string
	 */
	private function dirOf($ele) {
		$path = "";
		while (($ele = current($ele->xpath(".."))) && $ele->getName() == "dir") {
			$path = trim($ele["name"], "/") ."/". $path ;
		}
		return trim($path, "/");
	}

	/**
	 * Generate a list of files from the package.xml
	 * @return Generator
	 */
	private function generateFiles() {
		/* hook  */
		$temp = tmpfile();
		fprintf($temp, "<?php\nreturn new %s(__DIR__);\n", get_class($this));
		rewind($temp);
		yield "pharext_package.php" => $temp;

		/* deps */
		$dependencies = $this->sxe->xpath("/pecl:package/pecl:dependencies/pecl:required/pecl:package");
		foreach ($dependencies as $key => $dep) {
			if (($glob = glob("{$this->path}/{$dep->name}-*.ext.phar*"))) {
				usort($glob, function($a, $b) {
					return version_compare(
						substr($a, strpos(".ext.phar", $a)),
						substr($b, strpos(".ext.phar", $b))
					);
				});
				yield end($glob);
			}
		}

		/* files */
		yield realpath($this->file);
		foreach ($this->sxe->xpath("//pecl:file") as $file) {
			yield realpath($this->path ."/". $this->dirOf($file) ."/". $file["name"]);
		}
	}
	
	/**
	 * Implements IteratorAggregate
	 * @see IteratorAggregate::getIterator()
	 */
	public function getIterator() {
		return $this->generateFiles();
	}
}
<?php

namespace pharext;

/**
 * Source directory interface, which should yield file names to package on traversal
 */
interface SourceDir extends \Traversable
{
	/**
	 * Retrieve the base directory
	 * @return string
	 */
	public function getBaseDir();

	/**
	 * Retrieve gathered package info
	 * @return array|Traversable
	 */
	public function getPackageInfo();

	/**
	 * Retrieve the full text license
	 * @return string
	 */
	public function getLicense();

	/**
	 * Provide installer command line args
	 * @return array|Traversable
	 */
	public function getArgs();

	/**
	 * Process installer command line args
	 * @param \pharext\Cli\Args $args
	 */
	public function setArgs(Cli\Args $args);
}
<?php

namespace pharext\Task;

use pharext\Exception;
use pharext\ExecCmd;
use pharext\Task;
use pharext\Tempfile;

/**
 * PHP INI activation
 */
class Activate implements Task
{
	/**
	 * @var string
	 */
	private $cwd;

	/**
	 * @var array
	 */
	private $inis;

	/**
	 * @var string
	 */
	private $type;

	/**
	 * @var string
	 */
	private $php_config;
	
	/**
	 * @var string
	 */
	private $sudo;

	/**
	 * @param string $cwd working directory
	 * @param array $inis custom INI or list of loaded/scanned INI files
	 * @param string $type extension or zend_extension
	 * @param string $prefix install prefix, e.g. /usr/local
	 * @param string $common_name PHP programs common name, e.g. php5
	 * @param string $sudo sudo command
	 * @throws \pharext\Exception
	 */
	public function __construct($cwd, array $inis, $type = "extension", $prefix = null, $common_name = "php", $sudo = null) {
		$this->cwd = $cwd;
		$this->type = $type;
		$this->sudo = $sudo;
		if (!$this->inis = $inis) {
			throw new Exception("No PHP INIs given");
		}
		$cmd = $common_name . "-config";
		if (isset($prefix)) {
			$cmd = $prefix . "/bin/" . $cmd;
		}
		$this->php_config = $cmd;
	}

	/**
	 * @param bool $verbose
	 * @return boolean false, if extension was already activated
	 */
	public function run($verbose = false) {
		if ($verbose !== false) {
			printf("Running INI activation ...\n");
		}
		$extension = basename(current(glob("{$this->cwd}/modules/*.so")));

		if ($this->type === "zend_extension") {
			$pattern = preg_quote((new ExecCmd($this->php_config))->run(["--extension-dir"])->getOutput() . "/$extension", "/");
		} else {
			$pattern = preg_quote($extension, "/");
		}

		foreach ($this->inis as $file) {
			if ($verbose) {
				printf("Checking %s ...\n", $file);
			}
			if (!file_exists($file)) {
				throw new Exception(sprintf("INI file '%s' does not exist", $file));
			}
			$temp = new Tempfile("phpini");
			foreach (file($file) as $line) {
				if (preg_match("/^\s*{$this->type}\s*=\s*[\"']?{$pattern}[\"']?\s*(;.*)?\$/", $line)) {
					return false;
				}
				fwrite($temp->getStream(), $line);
			}
		}

		/* not found; append to last processed file, which is the main by default */
		if ($verbose) {
			printf("Activating in %s ...\n", $file);
		}
		fprintf($temp->getStream(), $this->type . "=%s\n", $extension);
		$temp->closeStream();

		$path = $temp->getPathname();
		$stat = stat($file);

		// owner transfer
		$ugid = sprintf("%d:%d", $stat["uid"], $stat["gid"]);
		$cmd = new ExecCmd("chown", $verbose);
		if (isset($this->sudo)) {
			$cmd->setSu($this->sudo);
		}
		$cmd->run([$ugid, $path]);

		// permission transfer
		$perm = decoct($stat["mode"] & 0777);
		$cmd = new ExecCmd("chmod", $verbose);
		if (isset($this->sudo)) {
			$cmd->setSu($this->sudo);
		}
		$cmd->run([$perm, $path]);

		// rename
		$cmd = new ExecCmd("mv", $verbose);
		if (isset($this->sudo)) {
			$cmd->setSu($this->sudo);
		}
		$cmd->run([$path, $file]);
		
		if ($verbose) {
			printf("Replaced %s ...\n", $file);
		}

		return true;
	}
}
<?php

namespace pharext\Task;

use pharext\Task;

/**
 * Ask password on console
 */
class Askpass implements Task
{
	/**
	 * @var string
	 */
	private $prompt;

	/**
	 * @param string $prompt
	 */
	public function __construct($prompt = "Password:") {
		$this->prompt = $prompt;
	}

	/**
	 * @param bool $verbose
	 * @return string
	 */
	public function run($verbose = false) {
		system("stty -echo");
		printf("%s ", $this->prompt);
		$pass = fgets(STDIN, 1024);
		printf("\n");
		system("stty echo");
		if (substr($pass, -1) == "\n") {
			$pass = substr($pass, 0, -1);
		}
		return $pass;
	}
}
<?php

namespace pharext\Task;

use pharext\Task;

use RecursiveDirectoryIterator;
use RecursiveIteratorIterator;

/**
 * List all library files of pharext to bundle with a phar
 */
class BundleGenerator implements Task
{
	/**
	 * @param bool $verbose
	 * @return Generator
	 */
	public function run($verbose = false) {
		if ($verbose) {
			printf("Packaging pharext ... \n");
		}
		$rdi = new RecursiveDirectoryIterator(dirname(dirname(__DIR__)));
		$rii = new RecursiveIteratorIterator($rdi);
		for ($rii->rewind(); $rii->valid(); $rii->next()) {
			if (!$rii->isDot()) {
				yield $rii->getSubPathname() => $rii->key();
			}
		}
	}
}
<?php

namespace pharext\Task;

use pharext\Task;

use FilesystemIterator;
use RecursiveDirectoryIterator;
use RecursiveIteratorIterator;

/**
 * Recursively cleanup FS entries
 */
class Cleanup implements Task
{
	/**
	 * @var string
	 */
	private $rm;

	public function __construct($rm) {
		$this->rm = $rm;
	}

	/**
	 * @param bool $verbose
	 */
	public function run($verbose = false) {
		if ($verbose) {
			printf("Cleaning up %s ...\n", $this->rm);
		}
		if ($this->rm instanceof Tempfile) {
			unset($this->rm);
		} elseif (is_dir($this->rm)) {
			$rdi = new RecursiveDirectoryIterator($this->rm,
				FilesystemIterator::CURRENT_AS_SELF | // needed for 5.5
				FilesystemIterator::KEY_AS_PATHNAME |
				FilesystemIterator::SKIP_DOTS);
			$rii = new RecursiveIteratorIterator($rdi,
				RecursiveIteratorIterator::CHILD_FIRST);
			foreach ($rii as $path => $child) {
				if ($child->isDir()) {
					@rmdir($path);
				} else {
					@unlink($path);
				}
			}
			@rmdir($this->rm);
		} elseif (file_exists($this->rm)) {
			@unlink($this->rm);
		}
	}
}
<?php

namespace pharext\Task;

use pharext\Exception;
use pharext\ExecCmd;
use pharext\Task;

/**
 * Runs extension's configure
 */
class Configure implements Task
{
	/**
	 * @var array
	 */
	private $args;

	/**
	 * @var string
	 */
	private $cwd;

	/**
	 * @param string $cwd working directory
	 * @param array $args configure args
	 * @param string $prefix install prefix, e.g. /usr/local
	 * @param string $common_name PHP programs common name, e.g. php5
	 */
	public function __construct($cwd, array $args = null, $prefix = null, $common_name = "php") {
		$this->cwd = $cwd;
		$cmd = $common_name . "-config";
		if (isset($prefix)) {
			$cmd = $prefix . "/bin/" . $cmd;
		}
		$this->args =  ["--with-php-config=$cmd"];
		if ($args) {
			$this->args = array_merge($this->args, $args);
		}
	}

	public function run($verbose = false) {
		if ($verbose !== false) {
			printf("Running ./configure ...\n");
		}
		$pwd = getcwd();
		if (!chdir($this->cwd)) {
			throw new Exception;
		}
		try {
			$cmd = new ExecCmd("./configure", $verbose);
			$cmd->run($this->args);
		} finally {
			chdir($pwd);
		}
	}
}
<?php

namespace pharext\Task;

use pharext\Archive;
use pharext\Task;
use pharext\Tempdir;

use Phar;
use PharData;

/**
 * Extract a package archive
 */
class Extract implements Task
{
	/**
	 * @var Phar(Data)
	 */
	private $source;

	/**
	 * @param mixed $source archive location
	 */
	public function __construct($source) {
		if ($source instanceof Phar || $source instanceof PharData || $source instanceof Archive) {
			$this->source = $source;
		} else {
			$this->source = new PharData($source);
		}
	}

	/**
	 * @param bool $verbose
	 * @return \pharext\Tempdir
	 */
	public function run($verbose = false) {
		if ($verbose) {
			printf("Extracting %s ...\n", basename($this->source->getPath()));
		}
		if ($this->source instanceof Archive) {
			return $this->source->extract();
		}
		$dest = new Tempdir("extract");
		$this->source->extractTo($dest);
		return $dest;
	}
}
<?php

namespace pharext\Task;

use pharext\ExecCmd;
use pharext\Task;
use pharext\Tempdir;

/**
 * Clone a git repo
 */
class GitClone implements Task
{
	/**
	 * @var string
	 */
	private $source;
	
	/**
	 * @var string
	 */
	private $branch;

	/**
	 * @param string $source git repo location
	 */
	public function __construct($source, $branch = null) {
		$this->source = $source;
		$this->branch = $branch;
	}

	/**
	 * @param bool $verbose
	 * @return \pharext\Tempdir
	 */
	public function run($verbose = false) {
		if ($verbose !== false) {
			printf("Fetching %s ...\n", $this->source);
		}
		$local = new Tempdir("gitclone");
		$cmd = new ExecCmd("git", $verbose);
		if (strlen($this->branch)) {
			$cmd->run(["clone", "--depth", 1, "--branch", $this->branch, $this->source, $local]);
		} else {
			$cmd->run(["clone", $this->source, $local]);
		}
		return $local;
	}
}
<?php

namespace pharext\Task;

use pharext\ExecCmd;
use pharext\Exception;
use pharext\Task;

/**
 * Run make in the source dir
 */
class Make implements Task
{
	/**
	 * @var string
	 */
	private $cwd;

	/**
	 * @var array
	 */
	private $args;

	/**
	 * @var string
	 */
	private $sudo;

	/**
	 *
	 * @param string $cwd working directory
	 * @param array $args make's arguments
	 * @param string $sudo sudo command
	 */
	public function __construct($cwd, array $args = null, $sudo = null) {
		$this->cwd = $cwd;
		$this->sudo = $sudo;
		$this->args = $args;
	}

	/**
	 *
	 * @param bool $verbose
	 * @throws \pharext\Exception
	 */
	public function run($verbose = false) {
		if ($verbose !== false) {
			printf("Running make");
			if ($this->args) {
				foreach ($this->args as $arg) {
					printf(" %s", $arg);
				}
			}
			printf(" ...\n");
		}
		$pwd = getcwd();
		if (!chdir($this->cwd)) {
			throw new Exception;
		}
		try {
			$cmd = new ExecCmd("make", $verbose);
			if (isset($this->sudo)) {
				$cmd->setSu($this->sudo);
			}
			$args = $this->args;
			if (!$verbose) {
				$args = array_merge((array) $args, ["-s"]);
			}
			$cmd->run($args);
		} finally {
			chdir($pwd);
		}
	}
}
<?php

namespace pharext\Task;

use pharext\Exception;
use pharext\Task;
use pharext\Tempfile;

class PaxFixup implements Task
{
	private $source;

	public function __construct($source) {
		$this->source = $source;
	}

	private function openArchive($source) {
		$hdr = file_get_contents($source, false, null, 0, 3);
		if ($hdr === "\x1f\x8b\x08") {
			$fd = fopen("compress.zlib://$source", "r");
		} elseif ($hdr === "BZh") {
			$fd = fopen("compress.bzip2://$source", "r");
		} else {
			$fd = fopen($source, "r");
		}
		if (!is_resource($fd)) {
			throw new Exception;
		}
		return $fd;
	}

	public function run($verbose = false) {
		if ($verbose !== false) {
			printf("Fixing up a tarball with global pax header ...\n");
		}
		$temp = new Tempfile("paxfix");
		stream_copy_to_stream($this->openArchive($this->source),
			$temp->getStream(), -1, 1024);
		$temp->closeStream();
		return (new Extract((string) $temp))->run($verbose);
	}
}<?php

namespace pharext\Task;

use pharext\Exception;
use pharext\Task;

/**
 * Fixup package.xml files in an extracted PECL dir
 */
class PeclFixup implements Task
{
	/**
	 * @var string
	 */
	private $source;

	/**
	 * @param string $source source directory
	 */
	public function __construct($source) {
		$this->source = $source;
	}

	/**
	 * @param bool $verbose
	 * @return string sanitized source location
	 * @throws \pahrext\Exception
	 */
	public function run($verbose = false) {
		if ($verbose !== false) {
			printf("Sanitizing PECL dir ...\n");
		}
		$dirs = glob("{$this->source}/*", GLOB_ONLYDIR);
		$files = array_diff(glob("{$this->source}/*"), $dirs);
		$check = array_reduce($files, function($r, $v) {
			return $v && fnmatch("package*.xml", basename($v));
		}, true);

		if (count($dirs) !== 1 || !$check) {
			throw new Exception("Does not look like an extracted PECL dir: {$this->source}");
		}

		$dest = current($dirs);

		foreach ($files as $file) {
			if ($verbose) {
				printf("Moving %s into %s ...\n", basename($file), basename($dest));
			}
			if (!rename($file, "$dest/" . basename($file))) {
				throw new Exception;
			}
		}

		return $dest;
	}
}
<?php

namespace pharext\Task;

use pharext\Exception;
use pharext\SourceDir;
use pharext\Task;
use pharext\Tempname;

use Phar;

/**
 * Build phar
 */
class PharBuild implements Task
{
	/**
	 * @var \pharext\SourceDir
	 */
	private $source;

	/**
	 * @var string
	 */
	private $stub;

	/**
	 * @var array
	 */
	private $meta;

	/**
	 * @var bool
	 */
	private $readonly;

	/**
	 * @param SourceDir $source extension source directory
	 * @param string $stub path to phar stub
	 * @param array $meta phar meta data
	 * @param bool $readonly whether the stub has -dphar.readonly=1 set
	 */
	public function __construct(SourceDir $source = null, $stub, array $meta = null, $readonly = true) {
		$this->source = $source;
		$this->stub = $stub;
		$this->meta = $meta;
		$this->readonly = $readonly;
	}

	/**
	 * @param bool $verbose
	 * @return \pharext\Tempname
	 * @throws \pharext\Exception
	 */
	public function run($verbose = false) {
		/* Phar::compress() and ::convert*() use strtok("."), ugh!
		 * so, be sure to not use any other dots in the filename
		 * except for .phar
		 */
		$temp = new Tempname("", "-pharext.phar");

		$phar = new Phar($temp);
		$phar->startBuffering();

		if ($this->meta) {
			$phar->setMetadata($this->meta);
		}
		if ($this->stub) {
			(new PharStub($phar, $this->stub))->run($verbose);
		}

		$phar->buildFromIterator((new Task\BundleGenerator)->run());

		if ($this->source) {
			if ($verbose) {
				$bdir = $this->source->getBaseDir();
				$blen = strlen($bdir);
				foreach ($this->source as $index => $file) {
					if (is_resource($file)) {
						printf("Packaging %s ...\n", $index);
						$phar[$index] = $file;
					} else {
						printf("Packaging %s ...\n", $index = trim(substr($file, $blen), "/"));
						$phar->addFile($file, $index);
					}
				}
			} else {
				$phar->buildFromIterator($this->source, $this->source->getBaseDir());
			}
		}

		$phar->stopBuffering();
		
		if (!chmod($temp, fileperms($temp) | 0111)) {
			throw new Exception;
		}
		
		return $temp;
	}
}<?php

namespace pharext\Task;

use pharext\Task;

use Phar;

/**
 * Clone a compressed copy of a phar
 */
class PharCompress implements Task
{
	/**
	 * @var string
	 */
	private $file;

	/**
	 * @var Phar
	 */
	private $package;

	/**
	 * @var int
	 */
	private $encoding;

	/**
	 * @var string
	 */
	private $extension;

	/**
	 * @param string $file path to the original phar
	 * @param int $encoding Phar::GZ or Phar::BZ2
	 */
	public function __construct($file, $encoding) {
		$this->file = $file;
		$this->package = new Phar($file);
		$this->encoding = $encoding;

		switch ($encoding) {
			case Phar::GZ:
				$this->extension = ".gz";
				break;
			case Phar::BZ2:
				$this->extension = ".bz2";
				break;
		}
	}

	/**
	 * @param bool $verbose
	 * @return string
	 */
	public function run($verbose = false) {
		if ($verbose) {
			printf("Compressing %s ...\n", basename($this->package->getPath()));
		}
		/* stop shebang */
		$stub = $this->package->getStub();
		$phar = $this->package->compress($this->encoding);
		$phar->setStub(substr($stub, strpos($stub, "\n")+1));
		return $this->file . $this->extension;
	}
}
<?php

namespace pharext\Task;

use pharext\Exception;
use pharext\Task;

/**
 * Rename the phar archive
 */
class PharRename implements Task
{
	/**
	 * @var string
	 */
	private $phar;

	/**
	 * @var string
	 */
	private $dest;

	/**
	 * @var string
	 */
	private $name;

	/**
	 * @param string $phar path to phar
	 * @param string $dest destination dir
	 * @param string $name package name
	 */
	public function __construct($phar, $dest, $name) {
		$this->phar = $phar;
		$this->dest = $dest;
		$this->name = $name;
	}

	/**
	 * @param bool $verbose
	 * @return string path to renamed phar
	 * @throws \pharext\Exception
	 */
	public function run($verbose = false) {
		$extension = substr(strstr($this->phar, "-pharext.phar"), 8);
		$name = sprintf("%s/%s.ext%s", $this->dest, $this->name, $extension);
		
		if ($verbose) {
			printf("Renaming %s to %s ...\n", basename($this->phar), basename($name));
		}

		if (!rename($this->phar, $name)) {
			throw new Exception;
		}

		return $name;
	}
}
<?php

namespace pharext\Task;

use pharext\Openssl;
use pharext\Task;

use Phar;

/**
 * Sign the phar with a private key
 */
class PharSign implements Task
{
	/**
	 * @var Phar
	 */
	private $phar;

	/**
	 * @var \pharext\Openssl\PrivateKey
	 */
	private $pkey;

	/**
	 *
	 * @param mixed $phar phar instance or path to phar
	 * @param string $pkey path to private key
	 * @param string $pass password for the private key
	 */
	public function __construct($phar, $pkey, $pass) {
		if ($phar instanceof Phar || $phar instanceof PharData) {
			$this->phar = $phar;
		} else {
			$this->phar = new Phar($phar);
		}
		$this->pkey = new Openssl\PrivateKey($pkey, $pass);
	}

	/**
	 * @param bool $verbose
	 * @return \pharext\Openssl\PrivateKey
	 */
	public function run($verbose = false) {
		if ($verbose) {
			printf("Signing %s ...\n", basename($this->phar->getPath()));
		}
		$this->pkey->sign($this->phar);
		return $this->pkey;
	}
}
<?php

namespace pharext\Task;

use Phar;
use pharext\Exception;
use pharext\Task;

/**
 * Set the phar's stub
 */
class PharStub implements Task
{
	/**
	 * @var \Phar
	 */
	private $phar;

	/**
	 * @var string
	 */
	private $stub;

	/**
	 * @param \Phar $phar
	 * @param string $stub file path to the stub
	 * @throws \pharext\Exception
	 */
	function __construct(Phar $phar, $stub) {
		$this->phar = $phar;
		if (!file_exists($this->stub = $stub)) {
			throw new Exception("File '$stub' does not exist");
		}
	}

	/**
	 * @param bool $verbose
	 */
	function run($verbose = false) {
		if ($verbose) {
			printf("Using stub '%s'...\n", basename($this->stub));
		}
		$stub = preg_replace_callback('/^#include <([^>]+)>/m', function($includes) {
			return file_get_contents($includes[1], true, null, 5);
		}, file_get_contents($this->stub));
		if ($this->phar->isCompressed() && substr($stub, 0, 2) === "#!") {
			$stub = substr($stub, strpos($stub, "\n")+1);
		}
		$this->phar->setStub($stub);
	}
}
<?php

namespace pharext\Task;

use pharext\Exception;
use pharext\ExecCmd;
use pharext\Task;

/**
 * Run phpize in the extension source directory
 */
class Phpize implements Task
{
	/**
	 * @var string
	 */
	private $phpize;

	/**
	 *
	 * @var string
	 */
	private $cwd;

	/**
	 * @param string $cwd working directory
	 * @param string $prefix install prefix, e.g. /usr/local
	 * @param string $common_name PHP program common name, e.g. php5
	 */
	public function __construct($cwd, $prefix = null,  $common_name = "php") {
		$this->cwd = $cwd;
		$cmd = $common_name . "ize";
		if (isset($prefix)) {
			$cmd = $prefix . "/bin/" . $cmd;
		}
		$this->phpize = $cmd;
	}

	/**
	 * @param bool $verbose
	 * @throws \pharext\Exception
	 */
	public function run($verbose = false) {
		if ($verbose !== false) {
			printf("Running %s ...\n", $this->phpize);
		}
		$pwd = getcwd();
		if (!chdir($this->cwd)) {
			throw new Exception;
		}
		try {
			$cmd = new ExecCmd($this->phpize, $verbose);
			$cmd->run();
		} finally {
			chdir($pwd);
		}
	}
}
<?php

namespace pharext\Task;

use pharext\Exception;
use pharext\Task;
use pharext\Tempfile;

/**
 * Fetch a remote archive
 */
class StreamFetch implements Task
{
	/**
	 * @var string
	 */
	private $source;

	/**
	 * @var callable
	 */
	private $progress;

	/**
	 * @param string $source remote file location
	 * @param callable $progress progress callback
	 */
	public function __construct($source, callable $progress) {
		$this->source = $source;
		$this->progress = $progress;
	}

	private function createStreamContext() {
		$progress = $this->progress;

		/* avoid bytes_max bug of older PHP versions */
		$maxbytes = 0;
		return stream_context_create([],["notification" => function($notification, $severity, $message, $code, $bytes_cur, $bytes_max) use($progress, &$maxbytes) {
			if ($bytes_max > $maxbytes) {
				$maxbytes = $bytes_max;
			}
			switch ($notification) {
				case STREAM_NOTIFY_CONNECT:
					$progress(0);
					break;
				case STREAM_NOTIFY_PROGRESS:
					$progress($maxbytes > 0 ? $bytes_cur/$maxbytes : .5);
					break;
				case STREAM_NOTIFY_COMPLETED:
					/* this is sometimes not generated, why? */
					$progress(1);
					break;
			}
		}]);
	}

	/**
	 * @param bool $verbose
	 * @return \pharext\Task\Tempfile
	 * @throws \pharext\Exception
	 */
	public function run($verbose = false) {
		if ($verbose !== false) {
			printf("Fetching %s ...\n", $this->source);
		}
		$context = $this->createStreamContext();

		if (!$remote = fopen($this->source, "r", false, $context)) {
			throw new Exception;
		}
		
		$local = new Tempfile("remote");
		if (!stream_copy_to_stream($remote, $local->getStream())) {
			throw new Exception;
		}
		$local->closeStream();

		/* STREAM_NOTIFY_COMPLETED is not generated, see above */
		call_user_func($this->progress, 1);

		return $local;
	}
}
<?php

namespace pharext;

/**
 * Simple task interface
 */
interface Task
{
	public function run($verbose = false);
}
<?php

namespace pharext;

/**
 * Create a temporary directory
 */
class Tempdir extends \SplFileInfo
{
	/**
	 * @param string $prefix prefix to uniqid()
	 * @throws \pharext\Exception
	 */
	public function __construct($prefix) {
		$temp = new Tempname($prefix);
		if (!is_dir($temp) && !mkdir($temp, 0700, true)) {
			throw new Exception("Could not create tempdir: ".error_get_last()["message"]);
		}
		parent::__construct($temp);
	}
}
<?php 

namespace pharext;

/**
 * Create a new temporary file
 */
class Tempfile extends \SplFileInfo
{
	/**
	 * @var resource
	 */
	private $handle;

	/**
	 * @param string $prefix uniqid() prefix
	 * @param string $suffix e.g. file extension
	 * @throws \pharext\Exception
	 */
	public function __construct($prefix, $suffix = ".tmp") {
		$tries = 0;
		$omask = umask(077);
		do {
			$path = new Tempname($prefix, $suffix);
			$this->handle = fopen($path, "x");
		} while (!is_resource($this->handle) && $tries++ < 10);
		umask($omask);
		
		if (!is_resource($this->handle)) {
			throw new Exception("Could not create temporary file");
		}
		
		parent::__construct($path);
	}

	/**
	 * Unlink the file
	 */
	public function __destruct() {
		if (is_file($this->getPathname())) {
			@unlink($this->getPathname());
		}
	}

	/**
	 * Close the stream
	 */
	public function closeStream() {
		fclose($this->handle);
	}

	/**
	 * Retrieve the stream resource
	 * @return resource
	 */
	public function getStream() {
		return $this->handle;
	}
}
<?php

namespace pharext;

use pharext\Exception;

/**
 * A temporary file/directory name
 */
class Tempname
{
	/**
	 * @var string
	 */
	private $name;

	/**
	 * @param string $prefix uniqid() prefix
	 * @param string $suffix e.g. file extension
	 */
	public function __construct($prefix, $suffix = null) {
		$temp = sys_get_temp_dir() . "/pharext-" . $this->getUser();
		if (!is_dir($temp) && !mkdir($temp, 0700, true)) {
			throw new Exception;
		}
		$this->name = $temp ."/". uniqid($prefix) . $suffix;
	}

	private function getUser() {
		if (extension_loaded("posix") && function_exists("posix_getpwuid")) {
			return posix_getpwuid(posix_getuid())["name"];
		}
		return trim(`whoami 2>/dev/null`)
			?: trim(`id -nu 2>/dev/null`)
			?: getenv("USER")
			?: get_current_user();
	}

	/**
	 * @return string
	 */
	public function __toString() {
		return (string) $this->name;
	}
}
<?php

namespace pharext;

use Phar;
use PharFileInfo;
use SplFileInfo;
use pharext\Exception;

class Updater implements Command
{
	use Cli\Command;

	/**
	 * Create the command
	 */
	public function __construct() {
		$this->args = new Cli\Args([
			["h", "help", "Display this help",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::NOARG|Cli\Args::HALT],
			["v", "verbose", "More output",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::NOARG],
			["q", "quiet", "Less output",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::NOARG],
			[null, "signature", "Show pharext signature",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::NOARG|Cli\Args::HALT],
			[null, "license", "Show pharext license",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::NOARG|Cli\Args::HALT],
			[null, "version", "Show pharext version",
				Cli\Args::OPTIONAL|Cli\Args::SINGLE|Cli\Args::NOARG|Cli\Args::HALT],
			[0, "path", "Path to .ext.phar to update",
				Cli\Args::REQUIRED|Cli\Args::MULTI],
		]);
	}

	/**
	 * @inheritdoc
	 * @see \pharext\Command::run()
	 */
	public function run($argc, array $argv) {
		$errs = [];
		$prog = array_shift($argv);
		foreach ($this->args->parse(--$argc, $argv) as $error) {
			$errs[] = $error;
		}

		if ($this->args["help"]) {
			$this->header();
			$this->help($prog);
			exit;
		}

		try {
			foreach (["signature", "license", "version"] as $opt) {
				if ($this->args[$opt]) {
					printf("%s\n", $this->metadata($opt));
					exit;
				}
			}
		} catch (\Exception $e) {
			$this->error("%s\n", $e->getMessage());
			exit(self::EARGS);
		}


		foreach ($this->args->validate() as $error) {
			$errs[] = $error;
		}

		if ($errs) {
			if (!$this->args["quiet"]) {
				$this->header();
			}
			foreach ($errs as $err) {
				$this->error("%s\n", $err);
			}
			printf("\n");
			if (!$this->args["quiet"]) {
				$this->help($prog);
			}
			exit(self::EARGS);
		}

		foreach ($this->args[0] as $file) {
			$info = new SplFileInfo($file);

			while ($info->isLink()) {
				$info = new SplFileInfo($info->getLinkTarget());
			}
			
			if ($info->isFile()) {
				if (!$this->updatePackage($info)) {
					$this->warn("Cannot upgrade pre-v3 packages\n");
				}
			} else {
				$this->error("File '%s' does not exist\n", $file);
				exit(self::EARGS);
			}
		}
	}

	/**
	 * Replace the pharext core in an .ext.phar package
	 * @param string $temp path to temp phar
	 * @return boolean FALSE if the package is too old (pre-v3) to upgrade
	 */
	private function replacePharext($temp) {
		$phar = new Phar($temp, Phar::CURRENT_AS_SELF);
		$phar->startBuffering();

		if (!$meta = $phar->getMetadata()) {
			// don't upgrade pre-v3 packages
			return false;
		}

		// replace current pharext files
		$core = (new Task\BundleGenerator)->run($this->verbosity());
		$phar->buildFromIterator($core);
		$stub = __DIR__."/../pharext_installer.php";
		(new Task\PharStub($phar, $stub))->run($this->verbosity());

		// check dependencies
		foreach ($phar as $info) {
			if (fnmatch("*.ext.phar*", $info->getBasename())) {
				$this->updatePackage($info, $phar);
			}
		}
		
		$phar->stopBuffering();

		$phar->setMetadata([
			"version" => Metadata::version(),
			"header" => Metadata::header(),
		] + $meta);

		$this->info("Updated pharext version from '%s' to '%s'\n",
			isset($meta["version"]) ? $meta["version"] : "(unknown)",
			$phar->getMetadata()["version"]);

		return true;
	}

	/**
	 * Update an .ext.phar package to the current pharext version
	 * @param SplFileInfo $file
	 * @param Phar $phar the parent phar containing $file as dependency
	 * @return boolean FALSE if the package is too old (pre-v3) to upgrade
	 * @throws Exception
	 */
	private function updatePackage(SplFileInfo $file, Phar $phar = null) {
		$this->info("Updating pharext core in '%s'...\n", basename($file));

		$temp = new Tempname("update", substr(strstr($file, ".ext.phar"), 4));

		if (!copy($file->getPathname(), $temp)) {
			throw new Exception;
		}
		if (!chmod($temp, $file->getPerms())) {
			throw new Exception;
		}
		
		if (!$this->replacePharext($temp)) {
			return false;
		}

		if ($phar) {
			$phar->addFile($temp, $file);
		} elseif (!rename($temp, $file->getPathname())) {
			throw new Exception;
		}

		return true;
	}
}
#!/usr/bin/env php
<?php

/**
 * The installer sub-stub for extension phars
 */

namespace pharext;

define("PHAREXT_PHAR", __FILE__);

spl_autoload_register(function($c) {
	return include strtr($c, "\\_", "//") . ".php";
});

#include <pharext/Exception.php>
#include <pharext/Tempname.php>
#include <pharext/Tempfile.php>
#include <pharext/Tempdir.php>
#include <pharext/Archive.php>

namespace pharext;

if (extension_loaded("Phar")) {
	\Phar::interceptFileFuncs();
	\Phar::mapPhar();
	$phardir = "phar://".__FILE__;
} else {
	$archive = new Archive(__FILE__);
	$phardir = $archive->extract();
}

set_include_path("$phardir:". get_include_path());

$installer = new Installer();
$installer->run($argc, $argv);

__HALT_COMPILER();
#!/usr/bin/php -dphar.readonly=0
<?php

/**
 * The packager sub-stub for bin/pharext
 */

namespace pharext;

spl_autoload_register(function($c) {
	return include strtr($c, "\\_", "//") . ".php";
});

set_include_path('phar://' . __FILE__ .":". get_include_path());

if (!extension_loaded("Phar")) {
	fprintf(STDERR, "ERROR: Phar extension not loaded\n\n");
	fprintf(STDERR, "\tPlease load the phar extension in your php.ini\n".
					"\tor rebuild PHP with the --enable-phar flag.\n\n");
	exit(1);
}

if (ini_get("phar.readonly")) {
	fprintf(STDERR, "ERROR: Phar is configured read-only\n\n");
	fprintf(STDERR, "\tPlease specify phar.readonly=0 in your php.ini\n".
					"\tor run this command with php -dphar.readonly=0\n\n");
	exit(1);
}

\Phar::interceptFileFuncs();
\Phar::mapPhar();

$packager = new Packager();
$packager->run($argc, $argv);

__HALT_COMPILER();
#!/usr/bin/php -dphar.readonly=0
<?php

/**
 * The installer updater stub for extension phars
 */

namespace pharext;

spl_autoload_register(function($c) {
	return include strtr($c, "\\_", "//") . ".php";
});

set_include_path('phar://' . __FILE__ .":". get_include_path());

if (!extension_loaded("Phar")) {
	fprintf(STDERR, "ERROR: Phar extension not loaded\n\n");
	fprintf(STDERR, "\tPlease load the phar extension in your php.ini\n".
					"\tor rebuild PHP with the --enable-phar flag.\n\n");
	exit(1);
}

if (ini_get("phar.readonly")) {
	fprintf(STDERR, "ERROR: Phar is configured read-only\n\n");
	fprintf(STDERR, "\tPlease specify phar.readonly=0 in your php.ini\n".
					"\tor run this command with php -dphar.readonly=0\n\n");
	exit(1);
}

\Phar::interceptFileFuncs();
\Phar::mapPhar();

$updater = new Updater();
$updater->run($argc, $argv);

__HALT_COMPILER();
; see http://editorconfig.org
root = true

[*]
end_of_line = lf
insert_final_newline = true
indent_style = tab
charset = utf-8
trim_trailing_whitespace = true

[*.md]
trim_trailing_whitespace = false

[*.json]
indent_style = space
indent_size = 4

[package.xml]
indent_style = space
indent_size = 1

[config.w32]
end_of_line = crlf
package.xml		merge=touch
php_raphf.h		merge=touch
config.w32		eol=crlf

# /
*~
/*.tgz
/.deps
*.lo
*.la
/config.[^mw]*
/configure*
/lib*
/ac*.m4
/ltmain.sh
/install-sh
/Make*
/mk*
/missing
/.libs
/build
/include
/modules
/autom4te*
/.dep.inc
run-tests.php
/.cproject
/.project
.libs/
/php_raphf_api.h
Doxyfile.bak
!/Makefile.frag
[submodule "travis-pecl"]
	path = travis/pecl
	url = https://github.com/m6w6/travis-pecl.git
	branch = master
# autogenerated file; do not edit
sudo: false
language: c

addons:
 apt:
  packages:
   - php5-cli
   - php-pear

env:
 matrix:
  - PHP=master enable_debug=no enable_maintainer_zts=no
  - PHP=master enable_debug=yes enable_maintainer_zts=no
  - PHP=master enable_debug=no enable_maintainer_zts=yes
  - PHP=master enable_debug=yes enable_maintainer_zts=yes

before_script:
 - make -f travis/pecl/Makefile php
 - make -f travis/pecl/Makefile ext PECL=raphf

script:
 - make -f travis/pecl/Makefile test
Michael Wallner <mike@php.net>
Yay, now known and unresolved issues yet!
# Contributor Code of Conduct

As contributors and maintainers of this project, and in the interest of
fostering an open and welcoming community, we pledge to respect all people who
contribute through reporting issues, posting feature requests, updating
documentation, submitting pull requests or patches, and other activities.

We are committed to making participation in this project a harassment-free
experience for everyone, regardless of level of experience, gender, gender
identity and expression, sexual orientation, disability, personal appearance,
body size, race, ethnicity, age, religion, or nationality.

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery
* Personal attacks
* Trolling or insulting/derogatory comments
* Public or private harassment
* Publishing other's private information, such as physical or electronic
  addresses, without explicit permission
* Other unethical or unprofessional conduct.

Project maintainers have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct. By adopting this Code of Conduct, project
maintainers commit themselves to fairly and consistently applying these
principles to every aspect of managing this project. Project maintainers who do
not follow or enforce the Code of Conduct may be permanently removed from the
project team.

This code of conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community.

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported by opening an issue or contacting one or more of the project maintainers.

This Code of Conduct is adapted from the
[Contributor Covenant](http://contributor-covenant.org), version 1.2.0,
available at http://contributor-covenant.org/version/1/2/0/.
raphf
Michael Wallner
# Doxyfile 1.8.10

#---------------------------------------------------------------------------
# Project related configuration options
#---------------------------------------------------------------------------
DOXYFILE_ENCODING      = UTF-8
PROJECT_NAME           = "Resource and persistent handle factory API"
PROJECT_NUMBER         =
PROJECT_BRIEF          = "A facility to manage possibly persistent resources with a comprehensible API.  Provides simliar functionality like the zend_list API, but with more flexiblity and freedom."
PROJECT_LOGO           = raphf.png
OUTPUT_DIRECTORY       =
CREATE_SUBDIRS         = NO
ALLOW_UNICODE_NAMES    = NO
OUTPUT_LANGUAGE        = English
BRIEF_MEMBER_DESC      = YES
REPEAT_BRIEF           = YES
ABBREVIATE_BRIEF       =
ALWAYS_DETAILED_SEC    = NO
INLINE_INHERITED_MEMB  = NO
FULL_PATH_NAMES        = YES
STRIP_FROM_PATH        =
STRIP_FROM_INC_PATH    =
SHORT_NAMES            = NO
JAVADOC_AUTOBRIEF      = YES
QT_AUTOBRIEF           = NO
MULTILINE_CPP_IS_BRIEF = NO
INHERIT_DOCS           = YES
SEPARATE_MEMBER_PAGES  = NO
TAB_SIZE               = 4
ALIASES                =
TCL_SUBST              =
OPTIMIZE_OUTPUT_FOR_C  = YES
OPTIMIZE_OUTPUT_JAVA   = NO
OPTIMIZE_FOR_FORTRAN   = NO
OPTIMIZE_OUTPUT_VHDL   = NO
EXTENSION_MAPPING      = no_extension=md
MARKDOWN_SUPPORT       = YES
AUTOLINK_SUPPORT       = YES
BUILTIN_STL_SUPPORT    = NO
CPP_CLI_SUPPORT        = NO
SIP_SUPPORT            = NO
IDL_PROPERTY_SUPPORT   = YES
DISTRIBUTE_GROUP_DOC   = NO
GROUP_NESTED_COMPOUNDS = NO
SUBGROUPING            = YES
INLINE_GROUPED_CLASSES = NO
INLINE_SIMPLE_STRUCTS  = YES
TYPEDEF_HIDES_STRUCT   = NO
LOOKUP_CACHE_SIZE      = 0
#---------------------------------------------------------------------------
# Build related configuration options
#---------------------------------------------------------------------------
EXTRACT_ALL            = YES
EXTRACT_PRIVATE        = NO
EXTRACT_PACKAGE        = NO
EXTRACT_STATIC         = NO
EXTRACT_LOCAL_CLASSES  = NO
EXTRACT_LOCAL_METHODS  = NO
EXTRACT_ANON_NSPACES   = NO
HIDE_UNDOC_MEMBERS     = NO
HIDE_UNDOC_CLASSES     = NO
HIDE_FRIEND_COMPOUNDS  = NO
HIDE_IN_BODY_DOCS      = NO
INTERNAL_DOCS          = NO
CASE_SENSE_NAMES       = YES
HIDE_SCOPE_NAMES       = NO
HIDE_COMPOUND_REFERENCE= NO
SHOW_INCLUDE_FILES     = YES
SHOW_GROUPED_MEMB_INC  = NO
FORCE_LOCAL_INCLUDES   = NO
INLINE_INFO            = YES
SORT_MEMBER_DOCS       = YES
SORT_BRIEF_DOCS        = NO
SORT_MEMBERS_CTORS_1ST = NO
SORT_GROUP_NAMES       = NO
SORT_BY_SCOPE_NAME     = NO
STRICT_PROTO_MATCHING  = NO
GENERATE_TODOLIST      = YES
GENERATE_TESTLIST      = YES
GENERATE_BUGLIST       = YES
GENERATE_DEPRECATEDLIST= YES
ENABLED_SECTIONS       =
MAX_INITIALIZER_LINES  = 30
SHOW_USED_FILES        = YES
SHOW_FILES             = YES
SHOW_NAMESPACES        = YES
FILE_VERSION_FILTER    =
LAYOUT_FILE            =
CITE_BIB_FILES         =
#---------------------------------------------------------------------------
# Configuration options related to warning and progress messages
#---------------------------------------------------------------------------
QUIET                  = NO
WARNINGS               = YES
WARN_IF_UNDOCUMENTED   = YES
WARN_IF_DOC_ERROR      = YES
WARN_NO_PARAMDOC       = NO
WARN_FORMAT            = "$file:$line: $text"
WARN_LOGFILE           =
#---------------------------------------------------------------------------
# Configuration options related to the input files
#---------------------------------------------------------------------------
INPUT                  = README.md CONTRIBUTING.md php_raphf.h src
INPUT_ENCODING         = UTF-8
FILE_PATTERNS          =
RECURSIVE              = NO
EXCLUDE                =
EXCLUDE_SYMLINKS       = NO
EXCLUDE_PATTERNS       =
EXCLUDE_SYMBOLS        =
EXAMPLE_PATH           =
EXAMPLE_PATTERNS       =
EXAMPLE_RECURSIVE      = NO
IMAGE_PATH             =
INPUT_FILTER           =
FILTER_PATTERNS        =
FILTER_SOURCE_FILES    = NO
FILTER_SOURCE_PATTERNS =
USE_MDFILE_AS_MAINPAGE = README.md
#---------------------------------------------------------------------------
# Configuration options related to source browsing
#---------------------------------------------------------------------------
SOURCE_BROWSER         = NO
INLINE_SOURCES         = NO
STRIP_CODE_COMMENTS    = YES
REFERENCED_BY_RELATION = YES
REFERENCES_RELATION    = NO
REFERENCES_LINK_SOURCE = YES
SOURCE_TOOLTIPS        = YES
USE_HTAGS              = NO
VERBATIM_HEADERS       = YES
#---------------------------------------------------------------------------
# Configuration options related to the alphabetical class index
#---------------------------------------------------------------------------
ALPHABETICAL_INDEX     = YES
COLS_IN_ALPHA_INDEX    = 5
IGNORE_PREFIX          =
#---------------------------------------------------------------------------
# Configuration options related to the HTML output
#---------------------------------------------------------------------------
GENERATE_HTML          = YES
HTML_OUTPUT            = .
HTML_FILE_EXTENSION    = .html
HTML_HEADER            =
HTML_FOOTER            =
HTML_STYLESHEET        =
HTML_EXTRA_STYLESHEET  =
HTML_EXTRA_FILES       = BUGS CONTRIBUTING.md LICENSE THANKS TODO
HTML_COLORSTYLE_HUE    = 220
HTML_COLORSTYLE_SAT    = 100
HTML_COLORSTYLE_GAMMA  = 80
HTML_TIMESTAMP         = NO
HTML_DYNAMIC_SECTIONS  = NO
HTML_INDEX_NUM_ENTRIES = 100
GENERATE_DOCSET        = NO
DOCSET_FEEDNAME        = "Doxygen generated docs"
DOCSET_BUNDLE_ID       = org.doxygen.Project
DOCSET_PUBLISHER_ID    = org.doxygen.Publisher
DOCSET_PUBLISHER_NAME  = Publisher
GENERATE_HTMLHELP      = NO
CHM_FILE               =
HHC_LOCATION           =
GENERATE_CHI           = NO
CHM_INDEX_ENCODING     =
BINARY_TOC             = NO
TOC_EXPAND             = NO
GENERATE_QHP           = NO
QCH_FILE               =
QHP_NAMESPACE          = org.doxygen.Project
QHP_VIRTUAL_FOLDER     = doc
QHP_CUST_FILTER_NAME   =
QHP_CUST_FILTER_ATTRS  =
QHP_SECT_FILTER_ATTRS  =
QHG_LOCATION           =
GENERATE_ECLIPSEHELP   = NO
ECLIPSE_DOC_ID         = org.doxygen.Project
DISABLE_INDEX          = NO
GENERATE_TREEVIEW      = YES
ENUM_VALUES_PER_LINE   = 4
TREEVIEW_WIDTH         = 250
EXT_LINKS_IN_WINDOW    = NO
FORMULA_FONTSIZE       = 10
FORMULA_TRANSPARENT    = YES
USE_MATHJAX            = NO
MATHJAX_FORMAT         = HTML-CSS
MATHJAX_RELPATH        = http://cdn.mathjax.org/mathjax/latest
MATHJAX_EXTENSIONS     =
MATHJAX_CODEFILE       =
SEARCHENGINE           = YES
SERVER_BASED_SEARCH    = NO
EXTERNAL_SEARCH        = NO
SEARCHENGINE_URL       =
SEARCHDATA_FILE        = searchdata.xml
EXTERNAL_SEARCH_ID     =
EXTRA_SEARCH_MAPPINGS  =
#---------------------------------------------------------------------------
# Configuration options related to the LaTeX output
#---------------------------------------------------------------------------
GENERATE_LATEX         = NO
LATEX_OUTPUT           = latex
LATEX_CMD_NAME         = latex
MAKEINDEX_CMD_NAME     = makeindex
COMPACT_LATEX          = NO
PAPER_TYPE             = a4
EXTRA_PACKAGES         =
LATEX_HEADER           =
LATEX_FOOTER           =
LATEX_EXTRA_STYLESHEET =
LATEX_EXTRA_FILES      =
PDF_HYPERLINKS         = YES
USE_PDFLATEX           = YES
LATEX_BATCHMODE        = NO
LATEX_HIDE_INDICES     = NO
LATEX_SOURCE_CODE      = NO
LATEX_BIB_STYLE        = plain
#---------------------------------------------------------------------------
# Configuration options related to the RTF output
#---------------------------------------------------------------------------
GENERATE_RTF           = NO
RTF_OUTPUT             = rtf
COMPACT_RTF            = NO
RTF_HYPERLINKS         = NO
RTF_STYLESHEET_FILE    =
RTF_EXTENSIONS_FILE    =
RTF_SOURCE_CODE        = NO
#---------------------------------------------------------------------------
# Configuration options related to the man page output
#---------------------------------------------------------------------------
GENERATE_MAN           = NO
MAN_OUTPUT             = man
MAN_EXTENSION          = .3
MAN_SUBDIR             =
MAN_LINKS              = NO
#---------------------------------------------------------------------------
# Configuration options related to the XML output
#---------------------------------------------------------------------------
GENERATE_XML           = NO
XML_OUTPUT             = xml
XML_PROGRAMLISTING     = YES
#---------------------------------------------------------------------------
# Configuration options related to the DOCBOOK output
#---------------------------------------------------------------------------
GENERATE_DOCBOOK       = NO
DOCBOOK_OUTPUT         = docbook
DOCBOOK_PROGRAMLISTING = NO
#---------------------------------------------------------------------------
# Configuration options for the AutoGen Definitions output
#---------------------------------------------------------------------------
GENERATE_AUTOGEN_DEF   = NO
#---------------------------------------------------------------------------
# Configuration options related to the Perl module output
#---------------------------------------------------------------------------
GENERATE_PERLMOD       = NO
PERLMOD_LATEX          = NO
PERLMOD_PRETTY         = YES
PERLMOD_MAKEVAR_PREFIX =
#---------------------------------------------------------------------------
# Configuration options related to the preprocessor
#---------------------------------------------------------------------------
ENABLE_PREPROCESSING   = YES
MACRO_EXPANSION        = YES
EXPAND_ONLY_PREDEF     = NO
SEARCH_INCLUDES        = YES
INCLUDE_PATH           =
INCLUDE_FILE_PATTERNS  =
PREDEFINED             = DOXYGEN \
                         TSRMLS_C= \
                         TSRMLS_D= \
                         TSRMLS_CC= \
                         TSRMLS_DC= \
                         PHP_RAPHF_API=
EXPAND_AS_DEFINED      =
SKIP_FUNCTION_MACROS   = YES
#---------------------------------------------------------------------------
# Configuration options related to external references
#---------------------------------------------------------------------------
TAGFILES               =
GENERATE_TAGFILE       =
ALLEXTERNALS           = NO
EXTERNAL_GROUPS        = YES
EXTERNAL_PAGES         = YES
PERL_PATH              = /usr/bin/perl
#---------------------------------------------------------------------------
# Configuration options related to the dot tool
#---------------------------------------------------------------------------
CLASS_DIAGRAMS         = YES
MSCGEN_PATH            =
DIA_PATH               =
HIDE_UNDOC_RELATIONS   = YES
HAVE_DOT               = YES
DOT_NUM_THREADS        = 0
DOT_FONTNAME           = Helvetica
DOT_FONTSIZE           = 10
DOT_FONTPATH           =
CLASS_GRAPH            = NO
COLLABORATION_GRAPH    = YES
GROUP_GRAPHS           = YES
UML_LOOK               = NO
UML_LIMIT_NUM_FIELDS   = 10
TEMPLATE_RELATIONS     = NO
INCLUDE_GRAPH          = YES
INCLUDED_BY_GRAPH      = YES
CALL_GRAPH             = YES
CALLER_GRAPH           = YES
GRAPHICAL_HIERARCHY    = YES
DIRECTORY_GRAPH        = YES
DOT_IMAGE_FORMAT       = png
INTERACTIVE_SVG        = NO
DOT_PATH               =
DOTFILE_DIRS           =
MSCFILE_DIRS           =
DIAFILE_DIRS           =
PLANTUML_JAR_PATH      =
PLANTUML_INCLUDE_PATH  =
DOT_GRAPH_MAX_NODES    = 50
MAX_DOT_GRAPH_DEPTH    = 0
DOT_TRANSPARENT        = NO
DOT_MULTI_TARGETS      = NO
GENERATE_LEGEND        = YES
DOT_CLEANUP            = YES
Copyright (c) 2013, Michael Wallner <mike@php.net>.
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice, 
      this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright 
      notice, this list of conditions and the following disclaimer in the 
      documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE 
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
# provide headers in builddir, so they do not end up in /usr/include/ext/raphf/src

PHP_RAPHF_HEADERS := $(addprefix $(PHP_RAPHF_BUILDDIR)/,$(PHP_RAPHF_HEADERS))

$(PHP_RAPHF_BUILDDIR)/%.h: $(PHP_RAPHF_SRCDIR)/src/%.h
	@cat >$@ <$<

$(all_targets): raphf-build-headers
clean: raphf-clean-headers

.PHONY: raphf-build-headers
raphf-build-headers: $(PHP_RAPHF_HEADERS)

.PHONY: raphf-clean-headers
raphf-clean-headers:
	-rm -f $(PHP_RAPHF_HEADERS)
# ext-raphf

[![Build Status](https://travis-ci.org/m6w6/ext-raphf.svg?branch=master)](https://travis-ci.org/m6w6/ext-raphf)

The "Resource and Persistent Handle Factory" extension provides facilities to manage those in a convenient manner.

## Documentation

See the [online markdown reference](https://mdref.m6w6.name/raphf).

Known issues are listed in [BUGS](./BUGS) and future ideas can be found in [TODO](./TODO).

## Installing

### PECL

	pecl install raphf

### PHARext

Watch out for [PECL replicates](https://replicator.pharext.org?raphf)
and pharext packages attached to [releases](./releases).

### Checkout

	git clone github.com:m6w6/ext-raphf
	cd ext-raphf
	/path/to/phpize
	./configure --with-php-config=/path/to/php-config
	make
	sudo make install

## ChangeLog

A comprehensive list of changes can be obtained from the
[PECL website](https://pecl.php.net/package-changelog.php?package=raphf).

## License

ext-raphf is licensed under the 2-Clause-BSD license, which can be found in
the accompanying [LICENSE](./LICENSE) file.

## Contributing

All forms of contribution are welcome! Please see the bundled
[CONTRIBUTING](./CONTRIBUTING.md) note for the general principles followed.

The list of past and current contributors is maintained in [THANKS](./THANKS).
Thanks go to the following people, who have contributed to this project:

Anatol Belski
Remi Collet
* TTL
sinclude(config0.m4)
ARG_ENABLE("raphf", "for raphf support", "no");

if (PHP_RAPHF == "yes") {
	var PHP_RAPHF_HEADERS=glob("src/*.h"), PHP_RAPHF_SOURCES=glob("src/*.c");

	EXTENSION("raphf", PHP_RAPHF_SOURCES);
	PHP_INSTALL_HEADERS("ext/raphf", "php_propro.h");
	for (var i=0; i<PHP_RAPHF_HEADERS.length; ++i) {
		var basename = FSO.GetFileName(PHP_RAPHF_HEADERS[i]);
		copy_and_subst(PHP_RAPHF_HEADERS[i], basename, []);
		PHP_INSTALL_HEADERS("ext/raphf", basename);
	}

	AC_DEFINE("HAVE_RAPHF", 1);
}
PHP_ARG_ENABLE(raphf, whether to enable raphf support,
[  --enable-raphf         Enable resource and persistent handles factory support])

if test "$PHP_RAPHF" != "no"; then
	PHP_RAPHF_SRCDIR=PHP_EXT_SRCDIR(raphf)
	PHP_RAPHF_BUILDDIR=PHP_EXT_BUILDDIR(raphf)

	PHP_ADD_INCLUDE($PHP_RAPHF_SRCDIR/src)
	PHP_ADD_BUILD_DIR($PHP_RAPHF_BUILDDIR/src)

	PHP_RAPHF_HEADERS=`(cd $PHP_RAPHF_SRCDIR/src && echo *.h)`
	PHP_RAPHF_SOURCES=`(cd $PHP_RAPHF_SRCDIR && echo src/*.c)`

	PHP_NEW_EXTENSION(raphf, $PHP_RAPHF_SOURCES, $ext_shared)
	PHP_INSTALL_HEADERS(ext/raphf, php_raphf.h $PHP_RAPHF_HEADERS)

	PHP_SUBST(PHP_RAPHF_HEADERS)
	PHP_SUBST(PHP_RAPHF_SOURCES)

	PHP_SUBST(PHP_RAPHF_SRCDIR)
	PHP_SUBST(PHP_RAPHF_BUILDDIR)

	PHP_ADD_MAKEFILE_FRAGMENT
fi
<?xml version="1.0" encoding="UTF-8"?>
<package
 packagerversion="1.4.11"
 version="2.0"
 xmlns="http://pear.php.net/dtd/package-2.0"
 xmlns:tasks="http://pear.php.net/dtd/tasks-1.0"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://pear.php.net/dtd/tasks-1.0
http://pear.php.net/dtd/tasks-1.0.xsd
http://pear.php.net/dtd/package-2.0
http://pear.php.net/dtd/package-2.0.xsd">
 <name>raphf</name>
 <channel>pecl.php.net</channel>
 <summary>Resource and persistent handles factory</summary>
 <description>A reusable split-off of pecl_http's persistent handle and resource factory API.</description>
 <lead>
  <name>Michael Wallner</name>
  <user>mike</user>
  <email>mike@php.net</email>
  <active>yes</active>
 </lead>
 <date>2015-12-01</date>
 <version>
  <release>2.0.0RC1</release>
  <api>2.0.0</api>
 </version>
 <stability>
  <release>beta</release>
  <api>stable</api>
 </stability>
 <license>BSD, revised</license>
 <notes><![CDATA[
* Internals documentation available at http://m6w6.github.io/ext-raphf/master/
* Travis support
* PHP 7 compatible version
]]></notes>
 <contents>
  <dir name="/">
   <file role="doc" name="AUTHORS"/>
   <file role="doc" name="BUGS"/>
   <file role="doc" name="CONTRIBUTING.md"/>
   <file role="doc" name="CREDITS"/>
   <file role="doc" name="LICENSE"/>
   <file role="doc" name="README.md"/>
   <file role="doc" name="THANKS"/>
   <file role="doc" name="TODO"/>
   <file role="doc" name="Doxyfile"/>
   <file role="src" name="config.m4"/>
   <file role="src" name="config0.m4"/>
   <file role="src" name="config.w32"/>
   <file role="src" name="Makefile.frag"/>
   <file role="src" name="php_raphf.h"/>
   <dir name="src">
    <file role="src" name="php_raphf_api.h"/>
    <file role="src" name="php_raphf_api.c"/>
   </dir>
   <dir name="scripts">
    <file role="src" name="gen_travis_yml.php"/>
   </dir>
   <dir name="tests">
    <file role="test" name="http001.phpt" />
    <file role="test" name="http002.phpt" />
    <file role="test" name="http003.phpt" />
    <file role="test" name="http004.phpt" />
   </dir>
  </dir>
 </contents>
 <dependencies>
  <required>
   <php>
    <min>7.0.0</min>
   </php>
   <pearinstaller>
    <min>1.4.0</min>
   </pearinstaller>
  </required>
 </dependencies>
 <providesextension>raphf</providesextension>
 <extsrcrelease/>
</package>
/*
    +--------------------------------------------------------------------+
    | PECL :: raphf                                                      |
    +--------------------------------------------------------------------+
    | Redistribution and use in source and binary forms, with or without |
    | modification, are permitted provided that the conditions mentioned |
    | in the accompanying LICENSE file are met.                          |
    +--------------------------------------------------------------------+
    | Copyright (c) 2013, Michael Wallner <mike@php.net>                 |
    +--------------------------------------------------------------------+
*/

#ifndef PHP_RAPHF_H
#define PHP_RAPHF_H

extern zend_module_entry raphf_module_entry;
#define phpext_raphf_ptr &raphf_module_entry

#define PHP_RAPHF_VERSION "2.0.0RC1"

#ifdef PHP_WIN32
#	define PHP_RAPHF_API __declspec(dllexport)
#elif defined(__GNUC__) && __GNUC__ >= 4
#	define PHP_RAPHF_API extern __attribute__ ((visibility("default")))
#else
#	define PHP_RAPHF_API extern
#endif

#ifdef ZTS
#	include "TSRM.h"
#endif

#include "php_raphf_api.h"

#endif	/* PHP_RAPHF_H */


/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * End:
 * vim600: noet sw=4 ts=4 fdm=marker
 * vim<600: noet sw=4 ts=4
 */
/*
    +--------------------------------------------------------------------+
    | PECL :: raphf                                                      |
    +--------------------------------------------------------------------+
    | Redistribution and use in source and binary forms, with or without |
    | modification, are permitted provided that the conditions mentioned |
    | in the accompanying LICENSE file are met.                          |
    +--------------------------------------------------------------------+
    | Copyright (c) 2014, Michael Wallner <mike@php.net>                 |
    +--------------------------------------------------------------------+
*/

#include <php.h>

struct user_cb {
	zend_fcall_info fci;
	zend_fcall_info_cache fcc;
};

struct raphf_user {
	struct user_cb ctor;
	struct user_cb copy;
	struct user_cb dtor;
	struct {
		struct user_cb dtor;
		zval data;
	} data;
};

static inline void user_cb_addref(struct user_cb *cb)
{
	Z_ADDREF(cb->fci.function_name);
	if (cb->fci.object) {
		Z_ADDREF_P((zval *) cb->fci.object);
	}
}

static inline void user_cb_delref(struct user_cb *cb)
{
	if (cb->fci.object) {
		Z_DELREF_P((zval *) cb->fci.object);
	}
}

static void raphf_user_dtor(void *opaque)
{
	struct raphf_user *ru = opaque;

	zend_fcall_info_argn(&ru->data.dtor.fci, 1, &ru->data.data);
	zend_fcall_info_call(&ru->data.dtor.fci, &ru->data.dtor.fcc, NULL, NULL);
	zend_fcall_info_args_clear(&ru->data.dtor.fci, 1);
	user_cb_delref(&ru->data.dtor);
	zend_fcall_info_args_clear(&ru->ctor.fci, 1);
	user_cb_delref(&ru->ctor);
	zend_fcall_info_args_clear(&ru->copy.fci, 1);
	user_cb_delref(&ru->copy);
	zend_fcall_info_args_clear(&ru->dtor.fci, 1);
	user_cb_delref(&ru->dtor);
	memset(ru, 0, sizeof(*ru));
	efree(ru);
}

static void *user_ctor(void *opaque, void *init_arg TSRMLS_DC)
{
	struct raphf_user *ru = opaque;
	zval *zinit_arg = init_arg, *retval = ecalloc(1, sizeof(*retval));

	zend_fcall_info_argn(&ru->ctor.fci, 2, &ru->data.data, zinit_arg);
	zend_fcall_info_call(&ru->ctor.fci, &ru->ctor.fcc, retval, NULL);
	zend_fcall_info_args_clear(&ru->ctor.fci, 0);

	return retval;
}

static void *user_copy(void *opaque, void *handle TSRMLS_DC)
{
	struct raphf_user *ru = opaque;
	zval *zhandle = handle, *retval = ecalloc(1, sizeof(*retval));

	zend_fcall_info_argn(&ru->copy.fci, 2, &ru->data.data, zhandle);
	zend_fcall_info_call(&ru->copy.fci, &ru->copy.fcc, retval, NULL);
	zend_fcall_info_args_clear(&ru->copy.fci, 0);

	return retval;
}

static void user_dtor(void *opaque, void *handle TSRMLS_DC)
{
	struct raphf_user *ru = opaque;
	zval *zhandle = handle, retval;

	ZVAL_UNDEF(&retval);
	zend_fcall_info_argn(&ru->dtor.fci, 2, &ru->data.data, zhandle);
	zend_fcall_info_call(&ru->dtor.fci, &ru->dtor.fcc, &retval, NULL);
	zend_fcall_info_args_clear(&ru->dtor.fci, 0);
	if (!Z_ISUNDEF(retval)) {
		zval_ptr_dtor(&retval);
	}
}

static php_resource_factory_ops_t user_ops = {
		user_ctor,
		user_copy,
		user_dtor
};

static int raphf_user_le;

static void raphf_user_res_dtor(zend_resource *res TSRMLS_DC)
{
	php_resource_factory_free((void *) &res->ptr);
}

static PHP_FUNCTION(raphf_provide)
{
	struct raphf_user *ru;
	char *name_str;
	size_t name_len;
	zval *zdata;

	ru = ecalloc(1, sizeof(*ru));

	if (SUCCESS != zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sfffzf",
			&name_str, &name_len,
			&ru->ctor.fci, &ru->ctor.fcc,
			&ru->copy.fci, &ru->copy.fcc,
			&ru->dtor.fci, &ru->dtor.fcc,
			&zdata,
			&ru->data.dtor.fci, &ru->data.dtor.fcc)) {
		efree(ru);
		return;
	}

	user_cb_addref(&ru->ctor);
	user_cb_addref(&ru->copy);
	user_cb_addref(&ru->dtor);
	user_cb_addref(&ru->data.dtor);

	ZVAL_COPY(&ru->data.data, zdata);

	if (SUCCESS != php_persistent_handle_provide(name_str, name_len,
			&user_ops, ru, raphf_user_dtor)) {
		RETURN_FALSE;
	}
	RETURN_TRUE;
}

static PHP_FUNCTION(raphf_conceal)
{
	zend_string *name;

	if (SUCCESS != zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "S", &name)) {
		return;
	}

	RETURN_BOOL(FAILURE != zend_hash_del(&PHP_RAPHF_G->persistent_handle.hash, name));
}

static PHP_FUNCTION(raphf_concede)
{
	char *name_str, *id_str;
	size_t name_len, id_len;
	php_persistent_handle_factory_t *pf;
	php_resource_factory_t *rf;
	php_resource_factory_ops_t *ops;

	if (SUCCESS != zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ss",
			&name_str, &name_len, &id_str, &id_len)) {
		return;
	}

	ops = php_persistent_handle_get_resource_factory_ops();
	pf = php_persistent_handle_concede(NULL, name_str, name_len, id_str, id_len,
			NULL, NULL TSRMLS_CC);
	if (!pf) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING,
				"Could not locate persistent handle factory '%s'", name_str);
		RETURN_FALSE;
	}
	rf = php_resource_factory_init(NULL, ops, pf,
			(void(*)(void*)) php_persistent_handle_abandon);
	if (!rf) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING,
				"Could not create resource factory "
				"for persistent handle factory '%s'", name_str);
		RETURN_FALSE;
	}

	zend_register_resource(return_value, rf, raphf_user_le);
}

static PHP_FUNCTION(raphf_dispute)
{
	zval *zrf;

	if (SUCCESS != zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r", &zrf)) {
		return;
	}

	RETURN_BOOL(SUCCESS == zend_list_close(Z_RES_P(zrf)));
}

static PHP_FUNCTION(raphf_handle_ctor)
{
	zval *zrf, *zrv, *zinit_arg;

	if (SUCCESS != zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rz",
			&zrf, &zinit_arg)) {
		return;
	}

	zrv = php_resource_factory_handle_ctor(Z_RES_VAL_P(zrf), zinit_arg);
	RETVAL_ZVAL(zrv, 0, 0);
	efree(zrv);
}

static PHP_FUNCTION(raphf_handle_copy)
{
	zval *zrf, *zrv, *zhandle;

	if (SUCCESS != zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rz",
			&zrf, &zhandle)) {
		return;
	}

	zrv = php_resource_factory_handle_copy(Z_RES_VAL_P(zrf), zhandle);
	RETVAL_ZVAL(zrv, 0, 0);
	efree(zrv);
}

static PHP_FUNCTION(raphf_handle_dtor)
{
	zval *zrf, *zhandle;

	if (SUCCESS != zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rz",
			&zrf, &zhandle)) {
		return;
	}

	php_resource_factory_handle_dtor(Z_RES_VAL_P(zrf), zhandle);
}

static PHP_MINIT_FUNCTION(raphf_test)
{
	zend_register_long_constant(ZEND_STRL("RAPHF_TEST"), PHP_RAPHF_TEST, CONST_CS|CONST_PERSISTENT, module_number);
	raphf_user_le = zend_register_list_destructors_ex(raphf_user_res_dtor, NULL,
			"raphf_user", module_number);
	return SUCCESS;
}

static PHP_MSHUTDOWN_FUNCTION(raphf_test)
{
	php_persistent_handle_cleanup(ZEND_STRL("test"), NULL, 0 TSRMLS_CC);
	return SUCCESS;
}
/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * End:
 * vim600: noet sw=4 ts=4 fdm=marker
 * vim<600: noet sw=4 ts=4
 */
âPNG

   IHDR   Ÿ   l   Áπ∞   gAMA  ±è¸a   bKGD      ˘Cª   	pHYs     öú   tIME›'…=)Ö    IDATx⁄ÏΩGè‹˘u5|*ÁúsWÁfhrò&hF“(YÚHê À €∆6º¥ó∏Ò'0m¥≤$¿0Ÿ3è$8$;áÍÆúsŒı.FÁ¢z,˘µ§Á}k£—Y··ﬁsœ9WÒˇã…dØ◊ãJ•Ω^ùNágœû…?áCÃf3,Ù˚}®’j4ºˆ⁄kP©T»d2Ë˜˚X,∞€Ì8<<ƒÓÓ.™’*>˜πœ·‰‰É¡ ùNV´+++∞X,8;;Cπ\Ü€Ì∆h4¬t:Eß”Å≈bAØ◊√ˆˆ64û={ß”	ª› Hß”p:ù0õÕË˜˚  ü ≠V›n7n‹¿|>áÀÂÇF£A6õÖ√·Ä«„A©T¬˘˘9VVV0üœ±≤≤Ç|>èx<éF£Å~øèÒxåÒxåõ7o‚‰‰*ï
'''hµZxÛÕ71üœá°R©–jµê…d–n∑è«1è1ùN·vªQ©T¸˘sáC‹∫uNßœû=É…dB,√`0ÄR©ƒ÷÷
Ö^∆„≈äáÍç7ﬁxÿÈt†R©p||ån∑ãH$çFÉ`0à—hÑF£ùNá—h è«˚˝á∏∏∏ÄF£Å≈bÅ’jE•RA(¬b±Ä√·¿≥gœ∞X,†’j°’j°”È`4Q≠V°—h†P(–jµ0è°”È–jµ`∑€·Û˘†T*—n∑a0`2ô†T*°P(0èP´’`2ôâD`6õ—l61õÕpˇ˛}å«cîÀeD"(
LßS¨ÆÆ¢◊Îa2ô  ÊÛ9ˆ˜˜—n∑±≥≥ÉŸlÜjµ
ã≈óÀÖx<éÛÛsáClooc8¢\.c>ü ‹n7l6:ùt:,NNN–h4‡t:±X,†R©  >üzΩ*ï
èùNÌv—h”ÈÕfız/„Òb≈CıŒ;Ô<Ùx<∏∏∏¿l6É¡`¿b±Ä’jE£—Ä¡`¿h4Ç«„Å√·¿p8Ñ…dÇ≈bA2ôÑÕfÉÕfC≥ŸD£—¿h4B$ÅÕfCª›Ü^ØG≥ŸD:ùF$ÅJ•¬h4Bª›FØ◊ÉB°Ä¡`@Ø◊ÉZ≠ÜﬂÔ«x<ñÄöL&x<	Ç◊Îïì ¥Z-Ïv;⁄Ì6jµzΩÃf3¶”)4ÊÛ9L&Ü√!b±“È¥¸Œ^Øát:çùùòÕfºˇ˛˚P(∏~˝:Ü√!™’*˙˝>Ïv;¶”)âãnﬁº	Ø◊ùNáL&ÉZ≠õÕÜïïYl*ï
ùNçF^ØÉ¡ ≥ŸvªV´›n≠VëH„Ò…dÌv6õ/„Òb≈Cı’Ø~ıa>üá√·Ä…díSp4·√?ƒ`0¿Õõ7Q´’P(∞ππ	çFÉn∑ãNßçFÉ≈bã≈Ç·pè«É—hÑ„„cáCh4¯˝~(
òÕf,å«c¿jµB£—¿l6√n∑C≠V L& @ß”a±X`8b4A°P@≠VCØ◊C´’¬b±¿„Ò†ﬂÔc:ù "–ÎıòœÁr¬L&ËızÙ˚}8 ¿h4Ç¡`@(í”–jµ¢^Ø√·p`±X»{6õMÏÏÏ¿Âra:ù ﬂU©T–ÎıòNßòL&¯Ë£è‡Òx‡Òx`µZëJ•`≥ŸêÕf°—h†◊Î·p8pttÑ\.£—à`0≥ŸåD"Å`0•RâóÒx±‚°˙¬æp}}•R	ÉAv`´’Ç«„Å”ÈÑR©ƒb±ÄÕf√b±@µZÖB°ÄœÁC≠V√|>á^Øá…dÇV´E≥ŸDøﬂG∑€Ö¡`Ä›n«ŒŒöÕ&É™’*¨V+¸~?F£l6õúÕf*ï
F£ã≈≥ŸÕfÛ˘F£QN¶*”ÈèG>3óÀ¡`0†V´¡l6C≠VÚCU*L&(ïJ(ïJx<®’j(ïJÃÁs8‹∫uZ≠jµZ≠J•jµ˝~:ùız^ØÛ˘ùNïJ^ØÒxr∫µ€m8ùNËızåF#ÃÁslll  É∫›.l6Íı:ä≈"<xÄÒxå¡`ÄóÒx±‚°˙Ê7ø˘0ëH†◊ÎAß”°Z≠‚ã^Øç˝~ç”ÈJ•ïJENõÕÜ…d´’
µZç≈b!?ÿ„Ò ç NOO%H„Òf≥Y˛˚t:E:ùF´’Ç—hÑ—hÑJ•B©TÇZ≠∆ÍÍ*4É∆„1ãÖú™≈bV´≈bF£QæÔl6ììP£—¿n∑Àb©’jpª›Ëvªü‰Ã*zΩT*L&T*Ü√°,Tá√ÅL&#≈3 8çFÙz=úûûbkk 0—l6—Èt†T*·t:aµZ·p8`≥Ÿp~~Ω^è∑ﬁz•R	≥ŸNßSNùNáóÒx±‚°¯˚øˇ˚≈b±@ª›∆l6ìá±X,∞X,P(áaµZQ*ï†T*a2ô–n∑qÌ⁄5
4õMX≠V)>’j5¨V+îJ%ç“È4NNNÍ´ØB©T¬ÌvK:íœÁ•àn∑€–ÈtòœÁ®◊Î  ÈéœÁC£—Ä›ná—hîáÃÇ<üœc:ùB≠Vc8¬Ìv£V´¡Îıb8b±X@≠VÀèœÁÛè«pª›–Îı®◊Î0ôL∞Ÿlá®◊Î˚˝h6õËvªà≈bH$r"`p8Çzı˚}ÉA®T*‰r9B°Z≠Ü√!ÊÛπ<kì…Ñ—h$)û^ØGª›∆ÀxºXÒP}Òã_|xqqÅzΩé`0àµµ5òL&‘Îu‰r9∏›nÃf3(
x<T*ÃÁs®T*,(
ÃÁs,4õM8ùN®T*
îÀeÿl6¨≠≠a±XHQX´’êœÁÂdJ0õÕ†R©†”È†P(–l6fÅ Z°P óÀ	B÷n∑ F£ì…·p›n˘|≥Ÿ6õ’jÉ¡ NßÉ
ÖB¢V´E∑€≈x<Ü…d¬`0¿h4Bß”A≠VC8Ü^Øá’j≈p8D:ùÜNßÉ«„X[ß”	§ÌÛ˘†”ÈP(êNßa∑€1ôL`≥Ÿ0ç∞≤≤µZçf≥âf≥â≈bÅóÒx±‚°Ú˘|Å jµJ•|>,¢—(Ü√!
.//a41ùNaµZQ(∞X,‡rπ≠â«„–jµ8::B£—ê¡`0@£—H
—Ìv°”È†T*%]·	¬‹ªV´……`4QØ◊a4&|<üœ•÷h4áËızröŸl6h4Y”È&ì	ùNáçF“&ˆtÙz=Å öÕ¶§>èÉ¡ •R	Û˘ÉÛ˘ÕfçFäzá√üœá\.áNßÉ¡Ä[∑n°—h†P(¿f≥¡Îı"ã·ÏÏÖBAN¸ÉÉºå«ã’ü˛Èü>‹ﬁﬁÜZ≠ÜNßC≥Ÿƒt:E∑€ï7Ë˜˚Ë˜˚(ïJP(Ë˜˚P*ïá√P*ï0ç∞Ÿl∏ººƒÒÒ1Ùz=|>ü‰ *ï
J•Ω^˝~Û˘NßS
OÖBÅ¡`Ä¡` µZ-pÈ∆∆Üº/°`ÖBÖBΩ^ã≈ÇJ•"π;ø´›nG2ôƒ|>áœÁ√t:ïE¬ìW´’b2ô†ﬂÔ£’jAß”°\.Cß”Iœh4…o p•¿á∞X,Ëvª0õÕp8ÚùJ•jµ÷◊◊·ızëNß%‡¡`ÂrˇˆoˇÜÈt
ß”âììhµZ¨ÆÆ‚e<^¨x®~ˇ˜ˇ·`0ê˛F≥ŸÑNßì^Fß”A*ïB•RëÎy8¬Âr¡h4"ç¢’jIóõª7#ì… ¬Èt
R≈¢ Å  »È¬ff4àÁx<∆p8ÑR©ƒd2DIß”IÛq8¢T*…IY.óè«Ö-`6õ•/ã¬ (ïJí2π\.ÈÛ$	xΩ^ÿÌv(
Å~ÅÄ‘Ã·Y_∞Q*ï˘|rKœp!=zÙV´UXÏÛX≠Vºå«ã’◊æˆµáÖBÁÁÁòœÁrÇE"áC‘j5‘j5,òÕfA©
‘j5Z≠‚ísW*Ãf3Ù˚}˘{>ü –Îı0ùNçF—Ìva±X‡p8–jµ§∞úNß(
Ú√YÄv:D"ÃÁsÙ˚}¯˝~¥Z-ƒb1L&îÀe‹Ω{ÂrÌv„Òkkk»Âr–Îıè«P©TW~è^ØG´’ÇœÁC∑€ïﬂÁÛ	à¿˜q8–jµ∏∏∏ê~lÙ⁄l∂+H”$ˆê∆„1F£ë§7/„Òb≈Cı;øÛ;m6“È4⁄Ì∂Ù9:ù<b±º^/&ìâ49…◊∫ººD≠V$áÅ·è(óÀ(óÀX__óﬁ∆d2ë¶•”ÈDØ◊ìÅ≠Ÿl"ì…`:ù¬l6C•R°\.£ﬂÔ√`0¿f≥¡Ô˜E¶—hHJsyy)?P£—†P(`}}]`Ërπåp8å≠≠-iíáV*ïêNß§ÿ&SÇßø^Øá—h´›n√·pt~qq!œ¬„Ò†^Ø#ëH¡ﬂ\´’P©T∞∫∫
´’*,ãóÒx±‚°˙Ê7ø˘êhQ8F @π\ÜR©DµZ™L Ä≈bZL£—@∑€ÖJ•Ç√·Ä≈b LßS·á17wπ\d¶√·áçFCò<YXd€l6çFa.Ët:®’jòÕfòL&¯|>T´UÈG∞∞eè®’ja:ù¬n∑£€Ìb6õ·¸¸ããì…ã≈NßSd±X`∑€—ÈtÑáÊt:°—h–Îı†’jqzz
≥Ÿã≈ÇD"!E~Ø◊É≈b¡˙˙:Ú˘<*ï
:ùé@«$Œ¶”i®’jié^^^¢”È`6õ…ü{è'™˚˜Ô?úÕf0ç“¡Ø◊ÎröL&d≥YËızÑ√a4õMáC Ä’j≈x<∆d2¡`0(¥€Ì"
!ÇÔ_≠V—ÎıÑ±=‡rπÑÆ≤åbtª]A çÅ Ü√!º^Ø¸πvª∑€çÈt*9??áF£⁄d2a>üc0  l6¶”)¶”)zΩû◊∆„1‘jµ–fx¬ãEL&!‘Ú$eo&â†›nc4!√·pH1ŒÇò˝$6ÇŸƒtª›0ôLÇæµZ-ºå«ã’õoæ˘ê]Û…dµZ-‘~ÖB•RâB° ùN'4£—(ΩõÕ&˘1ÛsµZì…$y6ô’F£:ùn∑[z‰≈-ÃÁsÈY$	h4I[xìvc±X˝2ôLH&ì»Âr¯˘|é·pùN≠VãB°Äx<≥ŸÖB!i“b±ÄﬂÔGπ\∆h4ínøV´ÖF£f∂J•Ç’j‰®—h¿b±`ccC>œÁÛa±X‡ÙÙZ≠>üOË@œü?GøﬂG≠VC4ÖZ≠ÜB°¿p8ÙN≠V£€Ì‚e<^¨x®æ˝Ìo?$l…¢ØV´¡Ètb8¢X,"
A°PH7û'õNß√t:ÖÀÂíkx4a4…)zyyâ·pàx<µZçÒxÉ¡ lÇL&#hV.ó√x<ñìëãÖû≈b!'¥ŸlñbX°P†›nc8¢—h≤¶P(–ÈtÑJCÈÜ√·êû
Â√·›nZ≠V¥C\hòb©T*ëIt:…≈çF#Ú˘<NOO±ªª+Ñ÷~øã≈"t°R©$⁄ŸlÜn∑ãF£Åd2âïïºå«ã’Á>˜πálÆ±◊P,—jµ†◊Îa6õ ´´´Ë˜˚“q',\($˜eëM¬ÀÀK…UŸ◊Èt“mµZ“Âß¨†’j¡Âr]y?íBâÂÛy·‘±∞X,h4Rî˚˝~IoîJ%f≥t:ä≈"\.t:t:∫›.˙˝>L&f≥aµZ·rπÓµX,P(H•R0õÕ≤8…Ñp:ùòœÁè«á√ÇPÒy2Œf3∏›nÙz=‰r9L&∏›n∏›nƒ„q‘Îuºå«ã’€oø˝–Ô˜Àï‹Îı0•sÌp8‡t:qyyy•%9î'N´’ÇV´∂v£—@(í^õâ¸azΩ^–¶vªçX,&Wr≥ŸD8ñﬁπnÃﬂôÇ‘ÎuÅh©™≠’jòL&ÿ⁄⁄¬b±@Ø◊ë`£—êaµZ•á@(C&ìI“≤"f≥Ãf≥úÆ
ÖB◊n∑˘| `6õeqûùùâ˛àiÂÛ˘±X√·π\ã˘|
Ö/„Òb≈CıÂ/˘a0ÑNß√ÈÈ)t:Œœœ·˜˚°◊ÎëÕf•eŒ û¿d2óBAµZç`0(?Ñ™SΩ^è¡`ÄB° £—(™]íP´’*\.‘j5≤Ÿ,:ùÏv;f≥ô¿©£—H»¨Ãô…»Âr–h4ÖBòÕfòœÁH&ìP´’òœÁ(óÀÿŸŸZU¿‡2*g2ôÑ≤3è%‡BR}LŒ˚:‰„Y,ËızËız∏\.Ù˚}·º≈„qA¢Ïv;*ï
çl6^∆„≈äáÍ´_˝ÍC˛Êú<Ì¥Z-Œœœ·t:1üœ·˜˚Q´’ÑZ ãEƒt¡`P–jlÚ˘º§ùNGh3kkkh4Ët:0ç¯√·—h4899ëÇ˜Ó›ªP©T¯¯„èEª£V´•…»^Ö’j≈h4íö$
%áåvÈŸà%¨€Ô˜%ø¶Ëp:ù
õ¿l6√`0à¨a<Kss>ü√jµ¢’j……;õÕ‡Òx$=S*ï"'!∞†P(∞∫∫ä—hÑóÒx±‚°z˝ı◊˙˝~Ùz=·|Òd™V´0ôLX]]E´’BµZÖV´Ö€ÌÜB°ê‚u0HÖ=•R)_ä‚<¥ÙÄ®V´òœÁR0gvª›¢!rπ\P(BùçFP*ïí˜◊j5¯˝~Ãf3Ñ√a8˘=Ù£†»n<K2üœa6õ—h4Æ4cô"ër¥X,âDÑ\Àﬁ…´f≥ì…~øÈtZH∑zΩ^
~ ®T*pπ\®’jËt:Ép8H•R∞X,Ë˜˚Ët:xè+™x<˛–l6c{{á*ïJÆn Éh4Ëız¬IÎızh4“˘W(Ú˜òÜÂ"Œcü§›nmáM@Ê¯.ó…dïJjµZ–,ïåF#ËızÃf3T*lmm…©˘ÙÈSë@¨ØØc8~“qˇ9•FØ◊K_*ï–Îı`4EÎ§”È†◊Î—ÎıÆ,
≠VÉ¡ è«#ÈÇ,¢©¡‚ÇS´’»ÂrRë%ﬁÔ˜a41DÍO1‚ÒÒ1*ï
^∆„≈äáÍˇM‚’Koá’’UiºQ¡ ^ãV´E.óìÊâC…É’jÖ≈bAß”ÅœÁC°P)˚7vª]±ÏﬂçFπ˛{ΩZ≠Ãf3îJ•÷îJ%≤Ÿ¨§1ùNâD:ùÎÎÎ0®T*(ïJ“±üL&"Í;>>ñf$ıOÅ@@<õç$∆Ú{)
‘j5)¨ó˚5¸-Õf&ìIÙY.óKDëH:ùùNôL±XÕfì…—h/„ÒÇ≈„ﬁΩ{óØ}óÀÖììAa
ÖÏvªÿk©T*¥€m)Óâ˙˝>¨V´@∫Z≠+++ÿ€€É€Ì∆d2A£—¿d2Aª›ÜB°8òí≠Vì…$Ww±XÑR©î^ d2A(ÜÀÂBØ◊÷Ç€ÌÜŸl∆⁄⁄≤Ÿ,û>}ä››]Ù˚}9πâˆ∏›n	˚4K·©W©T†R©`±XÌ¢cõìvª]ÙU#∫\.…˘ÁÛ9rπ\.ó iãEånjµ4çÙ±2ôå§u/„Ò‚ƒCI©4Oøãã¯˝~Q’Rê«"î]{Ó|RGŒŒŒ§Œ◊˙˙:ç2ôåÙ/t:úNß∏±Ô†—h`µZÖåÍÒx†◊ÎÖ5æúøõL&Q‚a
ÖBÖBx˜›w—Ô˜Ò∆o`8äÃ‹jµ¬f≥	 5õÕÑ°Nv¿h4B´’”∆∆:ùF£,2ôå¿0EÍt:®V´®◊Î¢«j∑€h4¢ÈbQMΩSøﬂø@  ∞π◊Î≈ÀxºxÒP}˘À_~8çF1üœπ°ƒÅVXÃ…m6çÜ|A≥ŸåzΩ.◊&)˛•RIÚvû<Qhp…ˇNûIüLÿ8å≈b‚K@≤úM&ÓﬁΩããã|¯·áÿﬁﬁo¡b±ì…É¡ Ø◊ãD"ÅNßÉX,õÕ&,oÉ¡…√¯9âV©T"ç Be—ØP($Õa_&óÀ°›nckkKƒÅ$ÂÚ‰ßNJ≠V„¸¸ã≈Br˘√√C∏\.‹∫uvª≠V/„Òb≈C9õÕÊõo¬Ìv#ùN„¸¸6õ…dRdÍπ\6õMPjÇT*ïÙ/XW*¥€mÃÁs!^éF#¯˝~awÎt:qE"ÚÂp8¡»	d2ô†V´q˚ˆm©®Íız(
®’jxı’WqvvÜD"!W˙|>ó¬îZ¶^Øáp8åµµ54õM
1Ùè«–jµ(óÀXYY¡÷÷ñ]ÆØØãã,ùöåF#F£ëÙMÿÌÁüaaÏrπ§ÔCø?óÀ≥Ÿå≥≥3hµZ¨≠≠âàíÃÙóÒx±‚°˙Àø¸ÀáJ•ÂrY<ıÏv;ÅÄ‰µªªªËvª®V´òÕf¢î-ãÇ™–N˘ïW^'ÿH$´’ä…dÇb±(¶œÁCπ\ñú◊jµ"ôL¬Ô˜√ÁÛa<#ëHH#î˝ˆ]H µ€Ì»f≥ßæ˘Êõ"_üÕfáÉàF£®’jÚÔhGV≠Vj4R√îÀeçFƒ„q—±?¬î¿d2¡jµäÔ^≠Vñçg¶”)¬·∞ cNß^Ø˘|—hÎÎÎ“,e:CCÕóÒxq‚°¯ﬁ˜æ∑òL&Ëvª¯‡ÉŸœ~V])ª¶4a>üã•3;ÌΩ^O∏ZëHDÆg:¡≤7√´ñ¶¸°PH§¬Ò‰#|úÕf1èqˇ˛}±Â¢Ø{*ïÇ¡`@´’í G£Qa)îÀe4lnn"üœK~Ïvª·t:]#öf±Xƒ*ö¿Ÿîî≥∑≤ππâV´∑€-ßÂl66å»Xg_ä@  ËµL—hTN˝Òxå^Øá>¯ oΩıñË®£—(Ò†HëÒ‡	˛ã‚A∏˝Wç¡LˇˇåGøﬂÛùb±(Ò†LÊˇÎxê˝õÏ’∑ø˝ÌáÏìº˘Êõ£“ñãΩ ‚Ω«ìÅù|≤û)û£¨B£—A5H/D´’JﬂÜ¸/."˛˝L&è« –h4H&ìX]]ÖÀÂ¬ŸŸvvvc¡À‡P±k∑€ë…d–ÌvÂÔr√(
T*8ùN	ßá∞ØîÕf≈’àƒX ?Hl•ƒA£—à “f≥I≥óJÚ˝l6jµöÄ~øáÕfπ\N
ùNoºÒ≤Ÿ,ÊÛπ,n¢zΩ.µÜ^ØÌ„qvvã≈ì…$˙´Èt
Ø◊ã`0(Ò–ÈtòÕfpπ\‚ﬁÀäÒH•RzΩèÀÀK¨¨¨¿Èt˛“xt:òÕfIm6“È4∫›.‚Ò∏X∂°,óÀp8≤.öÕÊ®>óÀawwWÂ*ïJPQ≠V+∑3)_å='ô&öÕÊ_9øÍ˛XéáÍﬂ¯∆√˜ﬁ{>üOÇA“#å§ñËız(ïJÿl6ÈV•'Ÿ”ïJ
Ö‚ä·»h4”MÖB!A¶ø:°d¬œf≥°PH8p888@8∆··°¿ƒ’j¡`BÃ\[[Cß”SÃF£!t"vˇùN'¶”)™’™∞h\I‘l<#ç ˚vª]Ÿ8•RÈäÚóR˝eOv•R)∂÷Àò›n∞Äl¶rÔΩ˜úNß,ˆà˙˝>
Ö∫›Æ∏˘r°®’j‘Îu)æ'ìâ®òóù{m6õ@Á<ËHÆV´"YûP¬˛í¡`@ ê”~}}GGGÖB8>>ñ˙¶Z≠¬Ô˜„‡‡@úúñ–-∏^Ø#õÕ¢—h»ÁsQRKF§R©î;–Îı‰÷µZ≠0ç¬é_û8c4°P(§Â·4ùNÂ–!ÄA=Z –Éˇ'?˘	º^Ø0I˛ﬂˆá›náF£ëgÆ¯Ówøª `8ä?ÇŸlF≠VC©T∂3U¥∏ë˜÷Ô˜?!B˛‹fåêËt:Ö^Ø(ôæLq»zÊÉ°˘%≠∏<èH
B°êÙv¯∞ü={&v…n∑[z9≈b~øZ≠èÁÁÁWX€‰ÛQ⁄–ÎıÑY@Vô&ìI\j3ôå¯˝ïÀeaeeEÇ±∫∫
ïJÖ'Oû¿l6c6õ!
	£úÇE
I\m4á√»ÂrÉÚ]»)‰Êf‰fùœÁr–p†ü<U√tgb<Ë•◊ÎQ≠V1èˆæ~˝:⁄Ì∂òú˙˝~1Õ°D¶^ØCß”!â|R‘´Tr`<˛\|4á§˚ŸlˆÒ‚œ≠2ôå0.É‹n∑4¨9@ÇRÚ…⁄'3É^!4œ©◊ÎH&ìÚ=ãB°êå<"sü∑1Ωπ1xr=ÏÏÏ†\.cssn∑[bˆøŸÙFü\(ˇ¯èˇ∏`
a6õqIß”Úe¯&≥ŸLaioú…dpxx(5M!yZÂ…»”bŸkè–*OüœáX,•RâÕÕM¨¨¨H¡In	¢oæ˘&ﬁ{Ô=îJ%)@…P(8??G•RA<«b±˜§ˇ¸œˇî≈i4%•8>>dÂÊ    IDATF±XD"ë¿p8Lß”¡n∑#è£R©à ë"E÷0§9úúú J*I_à””S\\\†P(HCˆoOÍ≠X{Pf¬ç¥úñ–Œ⁄n∑À"
pπ\¢ê¶Á≠jµÜ√!=z$ﬂÉß;kñ≈b!á·}É¡ ´’
É¡Ä≠≠-‹æ}[ÄäÒxåœ|Ê3x˜›wÖ¬ƒŸ`\p¥†Ùük©R©àEÅ¡`ÄœÁa©œÁC•R¡ÈÈ©@ÍÙ5‰mÕ˙îá:ôL+ôfsS—^ f≥ô 4t¨¢ˆÌı◊_«b±êLèÕÏ_∂?òΩq®ÜJ•Ç˙ÊÕõ»Âr888ê¸˝¯¯XNî’’U‘ÎuÙz=x<ô^H≤Ê£GèêœÁ%Ì„b!x±¸‚â¡^˛w¥cäƒ—5£—âDBÜ»ÌÌÌ°›ncmmJ•ˇÒˇ!é≠Ÿl7oﬁîSäSÍåL&ìXD≥ﬁ##·¯¯ P≠V±∑∑'¥†Èt
É¡Ä∑ﬁzn∑˚˚˚P*ïÉ‚ó¡œbJCï0g{±Fk6õ8;;√”ßOq~~.ll∆˛¢üœßüˇy6õ…Õe0ƒƒ4ïJ·ﬁΩ{≤∏9ó#}¯;©ÄÊÎ≈éü«z<â»çj2ô∞ππ	ÖBÅˇ¯«≤˜˜˜ëJ•p~~.©⁄/{oæ?≠‡Éﬂ∏qCÍÁt:çd2)ˆ/ZgLŸÁÛZ˛s¸o¸>T\/i¬è«c¨ØØ„˙ıÎ®’jÿ€€˚_Ìèl6ãn∑+÷©T
ÍããîJ%ëòsÇ≈∆∆Íı:ééé‡t:ã≈M¢®◊Î…IÃTÄ@∂ü~xÑS	ò∞ûXNã(`!€n∑±ππâ\.áJ•´’äııuhµZ§”iπÆ9≈É>B‡ÉË˜˚H$(
p8òœÁX__«|>ó|}:ù¢R©HzI≥¶ßπ\Nÿvª]
Ó¡` µ«õÚ¥^Nı⁄Ìˆ=kÜÈt*J∏xªsaå‡m√FÒd2êÇ5”≠ŸlÜ7n¿l6√Âr¡ÈtJÍ∆¶-oÅÂ≈π¸=>Ω¡x{òL&<˛·p◊Ø_Ÿõ…lÓ≤îX^¯\–À/÷Mï‘Ô˜Q,ÒŒ;ÔàtÑÙ)⁄á˙}ÿ®&Iöøâü…ıIÙë ◊Úã1ŒÁÛ®◊Î‚Ò»√Ò⁄dôÜOH¬€€€˘≈»Û˚˝2?∏”ÈàÖ—ˆ(Ë<
Ö∞≤≤É¡ øﬂ/hêV´ïtÃf≥auuá°P.óKñœÁ√÷÷ñ,\äÙÜ√°–`h
Ö‡Û˘PØ◊’qπ\RÉ)
πU)°gÔÜﬂm±X¿`0a:Ú‰	ç∆ïﬂKÜÙ!Ø◊+4{=Ã@B2ª…’´V´8;;y∑€çk◊Æ	‘n0ƒ®≈h4¬·p¿jµbss7oﬁî¥Q•Raeen∑^ØõõõrCq‹k%Ñ9ÀôP>'£p1ã	ÁœyÇd*pì”$’n∑„¡Éÿ‹‹ÑR©ƒüˇ˘ücwwÒx\@Z∫π›në’,Ë£TÜ^ât„u82Œàíì?˚≥?ÉŸlñÇëÀπÃ¨}®(∞Z≠“˜Û˚˝≤Œ‚Ò∏Lµ€ÌXYYë45ÑœÊr8ÜœÁª‚@øˇ”˛òL&0ôL(ãüîF+++®T*RÀ05aáú¡¢Ît:ï<ÿÌv#
°V´âÁG‘P§∑åLΩ˛˙Î∏}˚∂ê:âQ∑øø/6ÀúÊ—Ô˜—l6•”œö≈`0 è_ÒÙ£¢’l6£›nÀ˜‰Ïﬂ7nH*’h4Y‚®’Z≠Ürπ,ß˚1º-hriµZ≈qó(…§Ô;=yV´UlooÀ9zggóóóçFÚº9.’Îı‚ﬂ¯¬·0ﬁ}˜]S(Q°=ˆÊÊ&~˙”üb±Xú+ŒSﬁÿÿêzÀ`0àØ≈Ω{˜P.ó°’jÂÊN•R¬lwª›‚)OÚÓõoæâ@  ÀããáC¨≠≠]ÅÀ√·∞Ë¥êÕÁs|¸Ò«2≥ôYÜ{˜Ó¡Îı
˜ÒÙÙçF<@°P@°PÄV´ï⁄é0;3õÕÜo~Ûõ≤ykµ¨V´ ·ºÌì…$º^Ø8qU*$	a
|Á;ﬂÅ◊Îs!⁄ÉˇO˚ÉÈ3ŸˇÅ@‡ì>ô≈bëì†V´…(öÇÿÌv·d—≈U£—H1»˘LdpÄúB°¿÷÷ñ twÓ‹∆3eﬁëHDdíÕﬁÑ—h`a>üã¡?Éß”Èƒv´T*¡ÌvKä–h4d·t’h48::B∑€≈⁄⁄ö‹∞ÂrY∆üÚvÊ…ƒ[nssS‹fkµ¥Z≠»Ë˘`kµö,®f≥)∑2{D‹<Ùç0h4(ã(ïJíé∆b1Ñ√a¨¨¨ ¬h4bssSÄê`0(ñ’L∑].ó‹Rn∑[–4ˆÈ0ã≈‰˚≤¶"˚ù≠ ö X≠VAh˝~?~˜w_˚⁄◊‡Òx∞∂∂ÜÕÕM$ìIhµZ±å#c§\.#
…¡ƒvEìî÷–ÁÓ›ª¯ì?˘¨ØØ£›n#â
y„∆if”—ä>˚›nWD§lZﬂªwOÿ[[[2mfŸŒÄœﬂn∑£Z≠¢Z≠"üœÀa ≤ÄÎóÎvy‘”/⁄Ã4ç®îôLFNjròJq ;=˚6õMIá°“˚ÅΩ2îèèèÖsFQQ>á√Åb±(ã¬Âr!ëî”WWW·Û˘p~~.-nN6Yg∞–füÉΩ+Ç¥Ü&ßP(∞∂∂ÜΩΩ=qÑeNŒ x<—b1 úM≈iêÌv>üggg»d2¢¬Âº*öŒ–ú•ﬂÔ„‡‡@`a∂h<£’j%‰ ÆÆÆ
0¿CÖz*À#√Ù.â†—h†V´·ÚÚ?˝ÈO≈Rõ âÕf√ÓÓ.B°Ú˘<≤Ÿ¨p¸Ç¡ 
Ö™’™‘âÒxzΩáááh∑€hµZàF£X,∞€Ì‚çQ*ïÑ¢§R©Ñ¥Ãæ$◊]ä∑∑∑·t:ÒÖ/|Ôøˇ>⁄Ì∂l`üàD"2Xù}OˆC√·∞§⁄Ω^∑n›B6õEµZÖ◊ÎÜ—hÑŸlF,ìzèh53:W©T
Ω^ÔΩ?Ë¬6êJ•Ç“ÁÛ°’j°ŸlJ∑ªX,J±~ÁŒ°ô§”ië4
Iôæ‚§ﬁàÇøgœû·á?¸!t:|>"ëŒŒŒpyy	ß”)S…"·µl6õ%E`Z7ùN1õÕ†—h∞ππ)¥ˆ%\.ó∞∏):úœÁ¬¯vª›x„ç7†P(ûÆV´‚ã¡• èçáááòœÁ»f≥"AÁx‘\.'Ë!OM °PH¸6öÕ¶å˝)ïJB"e}I âê¯⁄⁄NOO1çê…d∞ΩΩ-N∑ßßßWÜÏ1McZHÑãu,ÉNß√˛˛>ﬁ}˜]ËızÉAiKîÀeYº¨'âƒÚPÀÂrxˇ˝˜ÒÔˇ˛Ô¯¯„è≈•âõo6õI=Nª*ë€Ì∂l:≤(\.>ˇ˘œã6K≠V#ïJ·Ó›ªrêYCÔ˙¡` åhF£J•RÍ%Z‡—¿î`Y@Ètóóó2Wõ
k™ß’[4ïr„WŸ\”&ì	 jµzÖ:√¸ù»»——ë)É}-")≤Z≠"ùN¨LN”≠;wÓ`4·—£GàD"2ˆî¨	∑€çd2ân∑ãÎ◊ØÀ&ËvªRT/èÌ°xè!õÕä≈ôF£ÅÀÂÉ*A
ã≈"∫&™}ÀÂ≤§wzΩèGxÉÙ§5Ûp8ƒd2Å›næ⁄|>'Yª›.3è…|1çÚ[Ëõ±µµ%-¢±t;2ç8<<ƒl6√µk◊§q˙¸˘s‰Ûy‰r91eoÜV€4Ê<>>Ü√·¿Ω{˜D)≠◊Î±X,pÎ÷-Ãf3<˛°PèG∆÷»Èvª(ã∏ˇæÄ
zΩ˚˚˚8==E"ë¿÷÷ñ®ÜâÿyΩ^d≥YA$U*ï|7éM"#ü)^≠Vì≈Ãtã^ã≈">à¥XF∞…πd…B“ÒÒ±xñîJ%åF#1we[ÄŸ—≤∑‰b±¿◊ø˛u1Q%Ù´Óè≈bÒâÜ¥ÉÉI/™’™,äeÍœµk◊dt˘xD$YË25"∆‘ás™666∞∑∑ázΩéT*ì…$H≠Ωÿÿ‰Un6õ±±±!jûí¨ Â≤q4!ç »õ££#looÀ„t:ÂªØT*˘+
ÑB!ºÛŒ;ËızxÚ‰â‹≤Ïõ1„TGª›.¨tˆ†&ì	rπ"ëàL£$=äÇu
af¢ï”È˚˚˚zΩp:ù≤àÖÇ4Û;ùvvv$É≥ŸGGGr"s¸,[-LÕidÍÒx$≈è«(
òL&Ú]x#Âr9Ù˚}cwwWZ(≥ŸLö⁄Ïv:°§áC°•ïJ%°¶q!2I&ì≤Ü¯æGGG¬ä≈b&ùûû ö\~fÑ„{Ωvwwe
&AçFÉl6{%¥Œ#-Ø€ÌJì‹Îı¢ﬂÔÀgÏÔÔ√f≥!ˇ ˚CIõbØ◊Ø◊ãb±(à:ª›.<?~-‡ÏÏÏ §ƒÂæ=8ÒÉÔqyy	øﬂ/5D"ë¿ù;w˝"ãy8 ˜°O≈5ÒJ'ΩG≠V£P(†R©¿·p‡∆çí2,d≥YÒX'©9ôLäcae≤à@y<|¸Ò«RÉëA¡oıt:-ß!ßëê•Aöß£xΩ^aº,/¶E¡`Ÿlˆ ∆É}3KgöI‡ÖÈa‰X,øﬂ/z´`0(3ë
“È¥∏¯ÚEù=1Z≠˛Îø˛:ùNPS¢πŸlVN}ﬁ‚À√ﬁ)]—h4í ÛˆÖBp88::)À≤CÒ£Gè†’j±ªª∑€-Ô√√úÊ5ì…DjÌR©Ñããi¯€l6—÷ë¢—h‡ızè«q„∆D£QòL&…8⁄Ì6≤Ÿ,<œØΩ?‘L}h≠≈é~.ó
N∑€ª.≤£ª›.666$HF£Oû<π“‰46g9Ac±X‡ÊÕõ∏∏∏n’Æ:ùN–;ûv¸Ã7n»cÛ5è„¡É888xïıK,ÉF£A8h>õÕJ^}qq≠V+}1¶ä¥
Àd2(ïJ–Îıÿÿÿ∏‚dÀ¡§1ôdB†Å¶òÙFß±Ëh4í˜Â…πÃ∂`â†Ü^Øa†√·ê±>ãEûMß”¡ˆˆ∂ëÀÂ≤Ùπ ˚˝>¬·∞*ï
…d√·€€€ÿﬂﬂøíâÃÁsièêΩÓız•Ùx<–jµx˛¸π¯«oll‡˛˝˚8::í[z4!ïJIØè0QÂ≈b!Ûñ766$ÕnµZh∑€∏∏∏¿  ä‘BÏi-?3“Ù¸~ø¸Vn¨zΩéZ≠Ü@ p%THì?ÀAÌƒ)Æ_øéü¸‰'Ët:Çp¸˘Uˆáí®?¨X,¢^Ø√n∑KM√>;ÍÑMyíé«c4¯˝˛+'S4ïJ%i˚Z≠f≥¬$ìÄåÊÌ‰@6úûû‚È”ßxÎ≠∑p˚ˆm®T*úûû"£V´â"˜ïW^A≥ŸD≠Vìq<zΩüˇ¸Á1õÕê…dÑfU(Æ äﬂ˘Œw‰§Ó˜˚®V´RÛ—“L≠Vã—µTîmê◊∆êX6¬YO\\\»©Ω¸“Ètpπ\ínT*IÛ˛ßxP3≈ò∂h6õ∏ººîñ≠ª’j5öÕ¶@¸‘”-≥<(Ï\,ÿÿÿOFZQ'ìIX,‹Ω{W®UgggW‚1èqÌ⁄5aó,3H^yÂLßS$ìI¯|>Ãf3úûûJ<èÖw ¥ê≥Àñ◊«Ë™T*Ÿ∞TÖ¸≤x∞>Â\l∂ù®⁄.ãBÁ‰õ_g(Ø]ª&(T∑€E*ïíÊE~ú»¯ÏŸ3‰Ö√aLßSÅ§Y∞.ˇx¢Ä§πçFºÚ +¢"≠V´Rºs$)õô$≈Ú§‚B'S∫Ÿl ˙’’UÅôŸÌ???á«„¡÷÷Ü√!ˆ˜˜a6õëœÁ•???G:ùñœaéNß!"§$∏
1o·¶%˚Äœ`0`ss´´´RP/≈Têh,g~-øÙzΩ0Í[≠âéééêœÁˇ«xêœ¥ò7!¨óû<y"æ˜f≥◊Æ]CØ◊CΩ^óaË|e£Ÿe/&ì	ÈtZho$F€ÌvòL&ƒ„Ò+Ò Ä43÷{çFº1úNßhÕ®d ¬LÒ(õ÷¨1ó”E¶‡ÕfSnB∂Ü∂∂∂˛[<∏>©McV¡ﬂS.óÒ≥ü˝´´´r»¸∫˚CIè\6≥Ÿ,4É¡ ÉßIybqHıg,√`0¿··°ˆ¯"4:õÕP.ó•ë€jµp||åP($år
çééé‰«ÚE6ÖœÁ√ø¯EÃf3qçFpª›¯“óæóÀÖ””SlmmassS
Tøﬂègœû°—hà}ó—hî[åµMøﬂG4ïTÄc_ Ÿ≈bÅR©•RâÎ◊Øıá{ggG®8¸~ÕfSåE≠V´Ùœ8_x˘`"A≠79‚Ëó≈ÉΩF
y˙ßR)‹∏qÎÎÎÚΩ©XfmôH$§∂[Óvª]ÏÌÌ…‚ﬁ€€ìÊ/•T\d≥Yüñ„qvvÜx<.º}çÜ¨£`0à››]A¸(-óÀ“ 8¬6—r∫H2√Éî:88ÄœÁ˚•Ò`M≠R©§Ûx<òNß(óÀxÌµ◊§’êÕfÌ˝°Ên„‡ÓP($^r pppÄ7n ëHà%¯~ø/j÷Ø˝Îx˛¸˘ïìê Z±p¥å…d»xYóNßÂs©>]&tíõ»A„gggx<(ïJ"Ïız¬Á€€€ìÊ$Ûir"ß”©PvñO√/}ÈKWbπPß”©˚Ÿœ~ÜªwÔ‚ÚÚ≥Ÿ+++“'#ïâÌì…$⁄(äS3ôåP3ôÃïMFÌ¡ñ˚˜Ô£R©»†Û_Øª›.í…‰ïlÇ,å˝ËGx<¯ãø¯È’Ì#∑”Ñ[é6‚ºdøﬂ/röB° 4;Z…]^^"èãù”æµµ5!ïÛfàSb8‡B°P‡˛˝˚x¸¯±¨«Èt*∂‘=ÚFdÌ8ôLêNß°’jÒ≠o}KºBR©‘ïx∞Õ6@:ùÚ@4E±XÑ√·ÄœÁïD.ó˚çˆá≤—h ùNãõQ"ëÄŸlÜ√·~Z*ïí¸ïB B° ©ƒ`0@≥Ÿƒ⁄⁄⁄ïöå©‚ﬁﬁöÕ&¥Z-l6Ó‹π#√∞sπúÁÛ9R©î ÀiÀ`0¶ß&^ø~]]3ôÅ ∂∑∑±≥≥#f/<J•n›∫%¡©T*H&ìÚÏ#˘˝~∏›nD"—y1Ö•”í√·∏“ﬂJ•R∏∏∏¿l6C6õE"ë∫-)PÏÈlll ïJ]©SòFëºººƒ……	¨VÎrÙ/äG>üóõg˘îßD4gßΩΩ=iŒZ≠V\ªvMî¡î¯j∑€r–ƒb1‹∏q?˙—èêL&ë…dêÕf‡¢¸Ös√º^/÷◊◊±ππy≈.ÄÉ:TAd≥Y¨≠≠a±X`ggG¶gí^WØ◊ëœÁ≈á9]dç©P($≈flñEªdÔS!∞∑∑áΩΩ=îÀe<˛\Ï‹öÕ&NOOQØ◊„˝°‹‹‹ü√·@°P¿l6  ÓÓ.¬·0¢—(|>üÏ~Ne§·H0ºrR-lÅ ä≈"~É  
Ö÷÷÷∞±±Å[∑na8‚Ò„«By:99πlÊÊwÓ‹ë<öﬂJ•ÇÌÌmapVÁ˜j4q)‚Ä∫R©ÑΩΩ=°…–◊èÚw¶[ÑÁÈ£¡ë´Ï©Ò&[ÑMoÉ¡ |»vªß”â’’UôàrÎ÷-Pn∑€%ï·3≥Ÿl–Îı∞X,≤àS©öÕ&n›∫u%Ω^©T
*ï
'''‚u≤|[ÓøwÔ˙˝>∂∂∂êJ•OˇÙO“zà≈b‚∏ºxô>F"‘Îu|˜ªﬂﬂî@ ÄV´%»aµZE*ï∫Y˘Oü>[ÆZ–∆‚ËËç¸±‘’lïÙz=….ÿD_Feys/$úN„Û˘`0P*ï§¬ÅÇè?∆ÒÒ1 Â≤X¬9ùNÑB!iﬂ¸ﬂÿj∑€ç◊_{{{˙‡E"ôŸDpïJ%ÉÿÌæˇæ8˙,ÁÙl‘ÌÏÏ»ø?==ï—£ÑQYËˇ‰'?¡ÒÒ1.//ØúƒÏU)ïJ¸›ﬂ˝Ú˘<Œœœã≈P©Tpyy)Äõ…d¬ù;w∞≤≤"Sz`ê·¡ò\¥ﬂ˚ΩﬂC$A ¿ÛÁœ±ΩΩ-` 9Ö$ÉÓÌÌ!‡‚‚6õMÍæYı4Èa¿óO`Jbñ{ãçF»≠*ï
_˝ÍWÖ∫ΩΩ-ua4Úﬂˇ}úüü_I≥	}˛Ûü«á~àØ|Â+∏ˇ>öÕ&Œœœqqq!VjD&ó„«ôeÙ≈†B˙È”ß"•aÎvª1ç‰…π°ôMˆ‡·I à[8±ŒŒŒÑæ¶—hP,±µµ%É˚ñy¶‘+NßS·∑~Î∑§n&!π◊Î¡l6ãïµo‰díÉâDDè«πœøÈ˛Pwª]iƒ∫›n“á¶4©TJË>jµÈtªªªP*ï¯◊˝Wƒb11Á_≤V´≈œ~ˆ3òÕf|ÈK__áGè	™®—hƒ3É|<¬f≥âÏ#
Rã≈êÀÂpvv&˝*è«ÉD"!'e°Pê>	yîú#Ã[åﬂ”jµ"`0‡¸¸\¨"ërπú‘îâDØΩˆö»83ôt*“Ãh∞…Ü&â∆≠VK“
≥ŸåL&s%≈&–B/ëzΩã≈õÕÜ¡` NO…dRdÙì…˚˚˚{ÛE6yøﬂ«ÈÈ)˛ÍØ˛
Õf?˛Òè—ÌvÒˆ€o≥ˇÙÙÕfÛ
j«¯)\__«ÂÂ%NOO•ı¿ZïáËÚM≈ƒZoôA¡f0oé|>è«õÕÜè>˙f≥Y¸Èπc±ò∏Z-?3 ≥∏Òò:œf3µDêã¿[:ùF*ïíø±≥≥#ﬁíÏŸrê‚o≤?‘ºn)<çFbñ¬Jπ\æb&‚t:·Òx–l6Q*ï‡Òxƒpe˘EßZj¡»Ì+
H$RêRØ≥|:q ¡≤/â`èG~P∑€≈  äËöhj≥ån>yÚNß7oﬁƒ˛˛>Â¡—:åã+"ùN√Îı
ê¡ÄÚƒá0¬hø~˝∫lb2U8 Åµ ”\ZÀQ.DoìÂ]§XñÀeëY(ïJ
X≠Vq≠‚B†Ö(ö⁄X≠VT´U$ìI|Â+_AµZ≈ˇ˘?ˇG‰zíyøÃ¯ ‡b±Xpxx((){àtcÏI[∂‡ˇ2]dÂ˜˚ØÿK0˝eî˝Õjµ*©ÈÂÂ•‘¨À/NzπººƒıÎ◊≈A*ïJ°”È»˜#–íœÁe”≥•aµZ·p8Ñ0@‰˘7›j$õÕJqIÚ-eﬁî∑s«SR>è±≤≤Çïï$â+÷¯bŒæ∫∫ävªç””Sëï–zÎ”˛jµÅ@@∆˝‹øﬂ˘ŒwP.óÂÙy¸¯1ç>˚Ÿœ
ª·⁄µk8??Ωk'™∂…„„ƒ·ÒxwÔﬁïÔ¡Ùã∞≤)ä’jÂuΩ^«˙˙∫§|T˝R:Ab)’úˆa∑€%0ø»€ÉÒX[[†ÖÜßº9ÈV≠VÒÙÈS\yóÀÖ`0à@  ª›éo˚€Ëız(ã899ÅÕf≥ŒÑé«„W6g#Ø¨¨»≠;ùNÒ∆o†X,ä¯ïEˇl6C0Dß”¡x<ñB˙o%n`ZP∫¬Mø≥≥ÉÁœüwíæıl{,õ:-≥dàéF#Ò!mkŸ_d9=ÁaŒÕÕı€Ô˜·Û˘pyy˘Ô5{1öÕ¸¥R©\‹±x‰ËùããiñÀeÅLó<ŸçôLF®E<•>˝∞Xßƒb1!yæÛŒ;∏}˚6NOO·t:Òπœ}ﬂ˚ﬁ˜D®HnQ3*´kµ≈Zé~π\ñ°›L©t:∂∑∑≈≤çûÑÓ9aÑπ¯r:Df¡ÍÍ™ÿY∫g;É¸æÕÕMQê~Ûi?Ûp‘Ï`0ÄR©ƒ……â∏Ûvª]Ù˚}I{iÖ¿ˆh4
çFÉ?˙£?˙ÑCßV„˝˜ﬂG©Tîç[ˆ.)Ò‡≠T(‡t:qÌ⁄5ÏÓÓ
dˇ˝Ô∏}˚6ﬁ{Ô=Òwd£û ì≈b}Îo˙xêF#°NßõÕ&›jµ*h%ë‹Nß#≥üó7OçFôZ≥úö.±ŸÆ‡Â˜ûL&xe≥YÑB!¸ﬂÿjú–v$A≠V√ÍÍ*Ü√°xAê´vtt$b>Ω^/1AåÂSÇ≈?5I\M¬0s˝e^£—àP(Ñ∑ﬂ~˜Ó›ìçπææéT*Ö¸‡B≤e†h7@˚3◊ØΩˆÊÛ9˙˝æ<¯ÂF&9pkkk¬E¨T*íJçF‹Ω{ôL≈bÒä-πÕfC<›◊ÒÒ±òˆ0ùòœÁ(ã¬v…ÁÛ˘|¢ÓV´’¯‡ÉÆ‘*¨…»ìT´’xÚ‰âh†8MíÚöÂ∞X,Üx<ì…Ñ/~Òã¬`/ã“¨wª›∞Ÿl∏∏∏Ÿæ◊Î˝oÈ"ùƒ
Ö˛ˆoˇùNGÍßB°Ä—hÑ?˛„?∆p8î¥ZØ◊KÌIøG:üùù!óÀ·‚‚·pX‚V´Ö∑ﬁzÉ¡ [[[ÿﬂﬂó¯Úwaì<˛¸J™®P(Ñ‰ÎızqrrÇh4äNßs%Ì£∫öúU÷~Òx\tuız]‘››nW‘øÓ˛Pñ‰µ9è«•'A◊ÿrπïJ%j\.N˚X6û\˛Ò≈bØæ˙*¬·0nﬂØñ&    IDATæçÈtäGè…‡Åˇ¯«¢\ûL&XYY¡¸¡ 
	™ˆÍ´ØJöDuÌÍÍ™˛∑Z-!ªéF#lmm!
a6õ!ôL"üœ√jµ"ïJ]Èçq@^,ì·u›JŸ>{l‰—Q§JùR±XƒŸŸô¡cÛôT 6j9c+ïJIæN¡‡ß)Bd}8Qìy¿CåMfÖB!
nzg∫›nº˝ˆ€x<á√Ë˜˚¢1£‚óåã≈ÇD"Ø◊+˙ÂCíÈ¢◊Î∆ÃoºÅ@  |M4ÌvÈtZ4bOﬁ∏qè{{{x˜›wëL&Ö3ÿÔ˜E˛‘Èt`2ôD˚≈˛']Ü√a,©Â?Õ]dÌ˘˙ÎØ„¡Éí5ŸQ˚◊ÌvQ.óQ´’ppp ZC∂ä ‡‰‰DÃ}ò˘¸⁄˚É≠Ñ‡ôørÓ/;ı$Ñrí ŸÁdqPÜæ|∫¢5ôLB¡˘∆7æÅ üœ„‚‚∑oﬂ∆——
"ë∂∂∂œˇ¸œb÷Ú⁄kØ·ÏÏ…dRöÄëHOü>äıW+++˜í«Êız•ÆzÚ‰…£
<)é,ïJ8??ø"6e⁄»õÉ∑>ˇôÙù7ﬁxC‹±X¯Û&bnyJ	ΩEñ©cÀ2 Déèèeû˝<»§ôNßR§ÉA1+bØã“Èt‚óóó0õÕ¢√#ê‚Û˘D∑|HíS»⁄ÎˆÌ€¯Ïg?ãb±àÛÛsâG4ï1K∏>˛p:ùíBÙ—G‚ß»>◊l6√G}ã≈ÇÒx,uk\ﬁ< ÄÁœüÀ ˘etë1&	Åu43(ñ&Û˘\ ≤·pàÕÕMîÀe‹∫uKRQ¶≥¸ˇøÈ˛PìƒªÏ=ûH$Æ8Q&œiÇ$∂“#ëÈ⁄ÚDÊªÑæôk3É¢CÛx<¬ıbù¡˙‡á?¸°‰ıè˘|ˇÚ/ˇ"¥£ÉÉ8‹Ω{—hT
SÇcqNOOØòx≤QKGZö ërEq&ÛxJ)8Ñ∑¨¡`êq=Àu&Â0≥Ÿn∑[N·ΩΩ=iz//íÂ˙bô¡7Û7ÿﬂﬂ«˜øˇ}looÀà£Ø|Â+‚FTìuH0D2ôÑ¡`@°P2âH‡…∞ßXñ‡Õ2]âƒh4¬ù;wÒÒ«ãMú…d¬……	?~,-äè>˙Nß◊Ø_óÅªV´IØå5ÊT*uÖ©‚˜˚1üœRO$‚±…ÛÚM6•e√ÏÄ1„…xêUÚ¯Òc«8§ÉSsÇ¡ éééíˇMˆáöÏ ˙Éh∑€òL&≤H:ùrπú∞)R©î(K}>ü∞+ñÉ§◊ÎÖSFê†X,äE◊l6ìÈˆâD+++¬uÀÂr≤Ë ˚˛˚Ô®€Ì‚ˆÌ€0ôL‚7o±Xp~~.'R>üG"ë@6õΩRoêÆ3ÑäÂÛ˘P´’D`j∑€—n∑·vª•%@_ΩZ≠ß”)Ë%Ω˛	Ìrr
ë/ß”)Dg“ù(Â˘4]©Tp˝˙uÈ˜¸ı_ˇµ S(àF£b JD.ïJI≠KÁ‰ãã§”illlu*ì…HL	÷–\v¶‘üÒ(ïJRßÒ;>~¸f≥€€€Ët:ÿ››ïx˜x<K¬~&ì	n‹∏! n	>üÈtZ@,ˆ5].û>}zÖÙ@^+πèL	∫]^^¬n∑ã∑?g5∞ﬂÂt:dy∞X,á•∂¸Mˆá: õÕ
ª°X,‚3ü˘í…§‰Á◊Æ]ÁY^rp™_tìq¡ÏÓÓ¬d2…¨^z¯-ÁØ¯M ‘b±@:ùF(í”‘l6ceeE–¶eˇs
!´’™Ë˜˚à≈b8??G2ô£¶nÅ@@,ÌåF£§UèG<ôrµZ≠OFì˛∫ùœÁ^–ŒÌ∑˚∑˙5ôLíöíò|~~ïJØ◊+s√®¿^Æ˘ÃïJ%Ò≠o}K∏xjµØºÚ
í…§ê¨Èá·˜˚Ö≈¬Ÿ\¥Wc⁄≈—¨º)≥Ÿ¨X#}⁄Æõœñı7uáú≥LÌ”j∫(óJ%!7”‰áô§^~'X‰4“∫`_HçF£<ﬂgœû˝7Ù÷÷ÊÛπh‹÷◊◊E‚§◊Îq~~~ÂsÈµá•«»ÁïJ•Ñ:F£_w®πk94çW -ΩÆ]ª&∑MµZ≈⁄⁄¢—(2ôå¿8≥âﬁ{|—‰ÖÛœ¯ yí¸?ÌùYS€Èôˆob–ä$$@ÉÒÜÌn∑Sß&ùNW•j™f¶Êd≤Uñì|æA*á˘"…A*©§;ùÆÙÙ§€v≥XÄ¨]BBBÏzﬁ˘]%údﬁt˙=¢QØ∂–Ûˇ?œ˝‹˜u˝.jbÊ?¥¨áÕœœ["ë∞_˝ÍW∂ººlÛÛÛHr“<x@
Ä¡¡Aã≈blkkK¥\öΩJà±±1ã≈bˆ≠o}KyXªªª∂∞∞ ≤/‚Ÿ˝˝}Â#„,Œd2ˆ¡ÿÒÒ±›ø_T&8®‚˝~øÂÛyÀÂrj2∞yP¢y<ûK⁄≈^»L2ô¥˛Á∂T*•óvyyŸˆ˜˜e≠'êc{{˚RWN!ZæNßcÂrŸ∆««≠Ÿl*áÕÎı⁄˛˛æ ûﬁ2’ƒƒÑª®)ù(
∂∑∑gïJ≈>|hfvi=¸~ø∆;ÿx|>ü∆ëHDö—££#Ÿò¸Æ·§z”¥â®wyyYúM Qlê≈P›áB!EI=}˙T¥+î˙T _ı˝p¸¯«?^ÕÁÛór∂¿Øü<??◊ê◊ÌvkûÄëØ7•css”*ïäJ2xò ·!|˛˘Á¢,Qßª\.´’j÷l6Ur¿ p:ù™…)›8ù(8q¿,s«Z__◊ã◊◊◊g∑n›≤`0hÔæ˚Ævjê‹ô∏O¬Ö˚˝
Ö¨›n€ˆˆ∂åßßßßçF5ò¶arpp`˝˝˝V©Tî2sttdÅ@@PVRlP¥õôπ›nÕqÅÄ-..Z≠VSâIJÂ⁄⁄ö,xÔê^°Ω£‘ÂÂ
åà–F2ìOOO5Æ‡°t:ùÂ,//Î4±ÌÌm9ƒááá•∆Ë]èF£aëHƒ‹n∑Ωzı ä≈¢N¥——Q[ZZ≤ŸŸYÎvªˆË—#U3¿OÈˆŒ≥ŸÏ%i!8Òü<yb˚˚˚‚n{ˆFÊíAã≈B¬íD4≤æØ˙~Ù_\\X<∑ŸŸY’´‹êõ@IÖgÄåßøø_úá^˚wÔN»å»öÉÉ˚”ü˛dáCZD`¬‰ˆÓÓÓ ∏GàD±X‘éL¯ÉYvrÊ=^ØW∞I ( 0?¸·•tÁÅG˝ÄDlooœ≤Ÿ¨∫û###öØpü†î¬çç∂3m_Œ\.ßMpM/˚ÇF–ÏÏ¨Âr9^ŸÿH® öÕ¶’j5´’jó8ëË9 2j4ísä}˘Ú•9éK0òﬁÓ"ÎN◊ñ¶D>ü◊f„vª56˘[Îˆ†∑“Ÿ‹‹¥f≥iÀÀÀö±Ò“–l‡3„‡&É¨˜NÓù±Æy4‡› ¸¢⁄Äù¬®‡PÚ1bjøÍ˚—üNße¡ =êÖ•!ámnnN"ñmNZ L›{¬ﬁõ¶”i5.Äbﬁæ}€¬·∞:@xåFFFlmmÕJ•í˝ˆ∑ø’Œ äå°",FîÑH‡SÎª\.k∑€ñH$.¢{[∂ò˝∏«‰Ûy+ïJvrrbõõõ2èB	&Lè{	âDdà≈ ñ˙ø∑T‰ƒ!ñïı@›M)
Ö*≠◊Îb%à¶ƒ¨n||‹∆««≠—h®s:22¢Ó"‚Á≈≈Eï˜¸B5??oÒx‹&''Ì£è>≤ııu€ÿÿ\hpp–jµö÷É\j÷ÉTP^‹ﬁ∏—Ô~˜;EYMMMô◊ÎïAó·Xºﬁ_NßSw9˛=ê(û√`0h˘|^
÷É,Ïb±x	›pvvfˇ?ﬁèvﬁWØ^ió& Ìv[,”ÓÛ˘‘aCP ¸¿Èt Ãÿ˚É≥±∏$hîJ%Ì(NßS`‘±±1i‘ŒŒŒ,€ŸŸôïJ%’ƒîƒô“âk∑€∫ƒ∑Z-5$(_Ÿ≠#ëàÕŒŒ
ßÃÜZ√Ìvk˛∑øøo·pÿ÷◊◊ÕÈt⁄Ω{˜dŒÑ`€n∑ï2I3¿Îı⁄‘‘î(K 
äÚ"r‚ø˘kssSJ∑€m˘|ﬁ¬·∞ˇØı‡I&ì"CE"1J∫›Æ0›tœﬁt”lB≠Aˆ6/{°P∞ÈÈiΩú®a Â≤›Ω{◊TbÒ‡ı6≈∞ÒáB!ô›n∑Ü î·Ãπ`N}”¥â^ppp–^æ|)[
˘x<n333
·‚HrH¿8_ı˝ËÔÔÔó@@YÕ≠VKlXt∞Î;<<‘ÓÚÚÂÀøxX&''mhhHÌsvev@ÜÆ·pÿ?~,≈à1Ó¥ÑÒ•”i°°ˇÈü˛I{\◊\∫\.ª}˚∂}Ûõﬂ¥°°!H0˜¢K
@Â˘ÛÁbRÊb~zzj{{{*ÉrπúLÉ«««Jº‰°$‚Á¡Vˇ¶zû]∏Z≠⁄ƒƒÑÕÕÕÈ.˜Æ««¨c,ìºå”î;√˘ﬁSürîMÅ‡Ü··aã≈b2çÚ‡ŒÕÕŸ≥gœdΩg=p∑≥°pƒ„ÒKπjµZMsSFú‚7æŸ`„;›››µ””Se§ôôe2)YHîãS`hh»\.óöEƒ1O¸™ÔG?ì{Üî<–eö‰∫OîsÅ@@æ)á√a’j’)Ùfpú«„ë6Ë	ZB.À O ô≈∞√ÃÃÃÿ»»àÌÏÏ»"ÅÄe<◊ÉHÑkØ}ÜπcÀÀÀ≤⁄Pd2	Y™ŒÕÕ©Y188h>üœÅÄåßúL≠VÀb±òÜ†ÎÎÎÚ∞Q~—Œ≥{˜Ói¶”{z0T><<¥«èõ”È¥zΩ.«.ò7◊N"<6ÇΩΩ==Hxπ”∞õ
=Ωï»ÈÈ©mllËü3¿¶ås8ösmmmŸ··°PÒx\0—ﬁˆ=œÜÀÂXññ;ä˜ÛÛs…¥z◊òRÔ›ü±
òAHbÑÚÅ€ŸŸïä˛ ≥Z∑€m+++ö‚O˚*ÔÎ—?;;k[[[Êt:-ãi∑ç≈bñL&’R/ïJ¬j—Ì"Å˚…õ6‘Ï¥æIsAËŸËßÉ599iëHDÃ<î¡`P™"l+ïävlè«c[[[÷h44:†·¡È477ßShrrRæ RV⁄Ì∂Õ¸∑îP(ÕôÛtª]{˘À_Ín˘ŸgüY©T2ß”©üÛ¸¸\.m.œΩs20i≥≥≥ínÕŒŒ⁄ÊÊ¶Z__üïJ%ù‹…n«ká™Ç4∏ùNG%Z$—¨®P(\í+·Û˚˝Ú3Û ÂrñL&5ÙÜÁQ©T$4˚˝íUÅìÎΩN0ÚÉjﬂáB!°øÈNCÒe{SÙ@Wën/ñ\–•RI≈/^»◊»ΩΩ€ÌJ»ÄßåÕ˝}?z◊£å6Ì`EÕf”n‹∏!h„Õõ7ÕÌv[6õµl6k>üOe.d˘ΩøP‡£ÇÔ«†;;∆…`0h>üœ\.ó∞cî(wÓ‹1ß”i}ÙëvÛ„„c[XX∞n∑kØ^ΩR–@ûﬁ›ŒÌv€¸«òÀÂ≤7nX©T⁄õM≥Ÿº‘ùbû7>>nØ_øV{ÜÛöΩΩ=ô)£—®≤≠°d}ˆŸg2Å.,,ÿ¯¯∏˝Òè@≥∑YD˜Ê∑€µl6k°PH;¯¬¬Ç<^(8z!±î2ÃuÙ]ƒz¥Z-k∑€z1zÖ∑lÄîÓ¨õÍ““íùúúX:ùıybbB–Ÿ≠≠-≈`ı"ÿÿåπ#ìFâàíÇÁn?X+Ωøx¯!GßR)K•RRú¸˘œ÷âÂvªUÿÚÚ≤MMMŸüˇ¸gUå6˛—˜£w=`ﬁ—m¡‘H4vÏ"Ωö∞zΩn.óÀí…§µZ-K$2U≤H~ø_•b/—ÇR__üE£QQ_Ab≥åçç©u\.ó≠€Ì b¬√èâ—ÎıZ2ô¥t:mÈt˙Ò
	’ÓÓÆïÀeµÈœœœ-çJù›l6eíd8ãˆ‰‰D†T“Aê„Äæµµe√√√≤É`ë¡$È˜˚-õÕ⁄ŒŒé
-JÔ%ûª.…0X*‚Ò∏fZîJºd5˚˝~Ÿ<<èÂr9¥7n\äx¢B@ù—+=Îç∑≠’jñH$¨øøﬂ≤Ÿ¨:y¢T•R)Û˚˝qÄ:œd2J≤U˜ö\ o8‚¬ÅÚupp†qL.óªÙù—ΩΩyÛ¶ºw¨ÅÍΩzUÃîgggÚmÀ8†^Øk~˜eﬂè7◊c ãŸgü}fááá
ÖÏ·√áñH$Ñ—¢î·Æ@À∑Î˛ÕØzU‘Ù}}}“ye≥Yç8¢…€öòòP˚¯ËË»Ó›ªg©T ä≈¢MOO[π\Vß,r>ü7ß”©≈£>N•RófOîñ•RIÚô?¸PÙΩ{˜TwS.ÓÄl´◊
ìH$§ y”6Éƒgjj 666‘	á√“
f≥Y{Ò‚≈_@:qjg2±ôôsª›ˆ‚≈u7È‡˙|>É¢bq«Ë»]T@/Ω¶j˙ó/_Z©T∫tc˝Ë«„qk4ñÀÂ‘–àF£Rœ3∑TÓ6·|kkk≤!ı~_$U∆b1Ÿ_∂∑∑"Ñ¬·pàè∏ΩΩ-FÔÔÂt:≠X,*ï'õÕ^zI„Ò∏}Ò≈*AÁÊÊî8va||\û≥••%k∑€ˆèºD{±é[∑n≠Ÿ¬¬ÇçååX•R±››]Õoò}y<€‹‹î>+ïJY©T≤µµ5€ÿÿ∏Ù¿—!Ûx<≤i À≈¿ñ/wÜÄÃ0P‡É¢Ï!y¸,åt:˝ãâD¥–h4îCà!wF~NÊ]¸.óÀˆˆˆlﬂ˛¯«?Z2ôºTÆÄ#·cxxXFI˚ ùœœœÌ˘ÛÁˆÍ’´øÿgx<•óºxÒ¬^ºx°q≠Ôôô+ã¢Î
≤p8¨!.∆S,åH≠I•RˆÒ«ˇ5•\ 0è«c˘|^Û*∆+4@Ú˘ºZÑ≥Ÿ¨˝ÈO“Ÿ+kC|‘u$∫Z≠Jqr0óÀŸ⁄⁄⁄%W;Í:z|èx»ËXEÀü	'Å Í˛™ØV´e;;;ˆeﬁ‘=˘|^Î1@ßfvvV¸çßOüÍnÔ˝¯¯ÿ‚Ò∏∞}}}∂ææ.ñn∑k£££Z|ËTGGGJ$	á√÷jµleeEIì–iAóJ%õûûëôÊHﬂÒx‹^ºxa_˚⁄◊§†®’jÊÒxtBÚbﬁ∫uÎR∂uπ\ûÄY
ª'Çh4*Âˇ˛˛æåxú®4`í`˘®V´mggG≥ºMÃjh¢∞¿á√¶¶¶Ã„Òÿì'Odœ˘œˇ¸O˚‰ìO≈ÂeeE6‘6©T B°ê6âb±x	o∆≈˚9÷Rø‡SãF£ÏÓÓ⁄[oΩ•Nrø-//[4MÃ^π\VÏ“ŸŸôMLLàá·ÒxÙºÑ√aÛzΩ699©óåT°L&c∑oﬂñ¢(ïJ]8”»‡4"ÛçÄˆáj‰CCÖÆ bÇl6+dõÜÃT*•¥“/Û~∞ôÚYR©î9~˙”üÆNLLÿ«láCmméﬁ`0(Èí'æ®jµ™{ßñ«„Q™&;<˜≠ììEtª]´V´∂∞∞ ôˆjË——Qiˇ0-F"ëKÅ0ˆ/..Ï≠∑ﬁ≤b±(âN,≥±±1]ËÈvÒ∞ÇÔ^\\Tõ¯ıÎ◊xCf£9@Æ‘‘îPe$¢ÑB!)_ø~≠&wÑü¸‰'÷ﬂﬂoâDBJ<aè«Ó‹πc—h‘~˚€ﬂZøΩ˝ˆ€÷n∑ı≤¨¨¨(zä›ñç}„ÑZ≠fÉÉÉÚ°AŒ¢ïÕùäë	ﬁ-øﬂØıd» 4˙◊æˆ5ÀÁÛˆ¯ÒcõûûVÁ¥R©à‹8¡m<∑ÒÒqÕ(q;–ÁD‡û)znnNG*#6z∑€≠4øﬂoÖBA›„Z≠fÀÀÀ∂ººl’jUÛd3iòåïT‚	†∑Ô˚ÅŸ‘Îıjﬂ˜ã_¸¢˚Í’+ªˇæuª]kµZV≠VUbÃŒŒ⁄˙˙∫€›ªw5/ïJJ©CM◊ÆX,*…·p®)¿ÑppP`ùØ˝Î“3ˆ∆ˇ◊Ãe∏ßÙv¥Ó›ªgwÔﬁµvªmõõõñÀÂ,â»,«âG‚àﬂÔÉ5óZ≠fÎÎÎ©p˜bø:ùŒ%ÀGª›ñééÔŒÎı⁄ÃÃåDª«5{Áùw¨—hËŒÇ˙°Ù€oømÎÎÎ∂ΩΩmoø˝∂î(‹≥∆∆∆leeEiö∑oﬂ÷:0ÄÖqò…dƒßÑhÀX•
Õí√√√ˆ·C›√8e9âË*‚Òä≈bˆË—#{˘Ú•˝Ê7øI∑V´Ÿˆˆ∂∫≠4ÀEPixΩ^1&›n∑>≥◊Îµ¡¡Aït{{{:AÈ¸ˆñﬂ$µíòâÓ±V´ô◊Îµ≈≈E—æFGGÌÛœ?∑\.gvxx(|“æ≥≥3∂ïï{˘Ú•}ô˜É∆ß˘≈≈Ö9nﬂæΩ⁄Èt4`àFcÇ¡%Ïz ò$\∞3ºı÷[v˜Ó]ª∏∏∞••%ªsÁéÂr9„8]ééélkkÀ<è<:ÂrY¡	{{{è«’§îõôô—<eff∆B°êÕÃÃ»á÷l6ÌΩ˜ﬁSp°ÅqC°êU*Çë.±ã”@Äõ¡)ÄÑäíÍÊÕõ633#.…”ßO5lµ˘˘y˚Ù”Omhh»ÊÊÊ‘BÙËë¿3çF√fgg•ÿ≤˝ËGñNßbq˚ˆm˙yHõÕ¶J¨ÒÒqÀd2V(¥V(1ä≈¢E£QÕúÇ¡†Ö√a{˝˙µ0k≠Û˚NOO€£Gètr3to6õ∂≤≤"˚
eMIπâ|jµZˆÙÈSE¸ûúúÿ√á≠’jŸÃÃå$lÃMë.ıä˝£ÒzΩ∫Ãœœ€∞-//[0î!Ù—£GÍ ¢b«∑ªªkÛÛÛ: »,ÁE=::≤˜ﬂﬂ666tw˛2Ôé{÷√ÒÙÈ”’gœûI›Ä∞–MµZ’?CU©Tƒ$8õªÀÂ≤˘˘y´◊ÎR-≥+ò6::™ˇüŒ$wòÄtòÒp"‹∏q√n›∫•Ä¸MÅ@@'^Ø)[Ω^O§V´©3»)∑±±!ÊﬂŸŸôºQÌv€≤Ÿ¨E£Q◊óÃån2ô¥n∑´†n2πZ≠ñΩxÒBA05z-BÊÒxl{{[w®o|„j#3‘‰œKß”V´’¨T*i¿Œz Ëeâ∏\.ã«„öÖ—-Önåı(
…Ä çcß”±h4*€µµ5iAôá÷j5iTQ™‡)Ñ\Ø◊ÌıÎ◊Z"ó†K%ìIQÇ	|¿∑óœÁm~~^ee&ì—‡;Z&ì±≠≠-©/¿áCüB"«Ça8ÏDL£π\N¯Ö/Û~Ù⁄i$÷¯Ÿœ~÷ÖqÁÛ˘§ﬂZ\\îw	D±◊ÎUnñœÁSÕ…ùªA©TR#ÑZπ\∂••%€ﬂﬂ◊áK6z?qp4‡¡SRÅŸ*ãñ…d§ä@k»]‰ìO>ëWåœÖ‰ÜŸ>;†’ããã≈br.OOO€——ëîÂ¯à∞%Ï≠”Èÿ˛˛æÉAë™@ï—U}ÁùwÏ‚‚¬ˆ˜˜uè!•ìŸ–‰‰§ˇΩŸÿKKKÚ5ë·iøÑ-ÓR4~˛⁄zT*ªyÛ¶5õMJy·‰ﬁªúÙòRi&0s8ö}"ÿm∑€ˆÈßü⁄ªÔæ´{€ˇ∂ò1ë‚@/ïJÚ˜ƒ|¡8	ôm=∏~0∞>>>∂«è[7==m›n˜ØÆ«?Ú~ÙÆá„…ì'´¸Mπ\∂√√CÂf°∫F›qtt§K"`‚R€Ì∂Ï˙π\ŒÓﬂøØÀ*Ù&‰ˇPë⁄Ì∂0Ÿ^ØW§')e1¿’ÎuIîB°êBÈ°®xˆÏô[6õï‚bppPãÜM¶7Î¯¯∏%	QàÈ^—iäF£∂ªªkÌv[ßÆœÁìâ!,I0ÿ<í…§≈„qÛ˘|ˆÍ’+ªuÎñ.ÙÄe(≈QÉÄ≥kµZè«ÖF@ùQ©TÑsËS`LÃÁÛˆ‡¡ÉKòpde√√√≤÷†Â„ûäïa:P$≤òQπ†§ßâÇ5…≥gœldd‰ÔZÈ‡‹n∑÷∑2∞ﬂÔWb£âøµccc6::*$÷Î◊ØıåommŸÚÚÚ%	™ê/˚~ÙÆá„?¯¡Í⁄⁄ö·ÊÁÁ’ô
ÖB≤ú˜÷ò¯jQkŒ:==µX,¶ˆf´’“ãÇŒ√‚^∑0°z¢∏t˙|>Õ>∞V–%¸‡É‘≠Ck»¸Z•Rï˘RµZU{ò[Ne˛›ƒƒÑJ
.€|îa4is èççY4U¯ﬂÕõ7mmmÕ¶ßßm}}›|>üT˘ëHƒ÷÷÷TŒ˝≠ıh4“>b∂d=Ë ≥å-ÄÔ–¯ﬂ÷Év>.3Ã^ÍoÔz †•˘”ÌvøÚzÄ`ÑSÁW]zããã∂ææÆı˚˝j∏∞_ˆ˝Ë]«wø˚›U¬âmaaAG4j˙J•bááá
†ÜcéàŸ5/A÷®ì3ôåMMM©ïè«ÕÂrŸ⁄⁄öÎ»200†ª\ø$W˘|ﬁ"ëà2±à2=99ë‡ì	Ø§%¸DΩÅﬂ’Å8¿ﬁÅ ¯‚‚B-|JöL&cwÓ‹±ÛÛs5-@∞£¡Ñ˜x<∂ººlµZMﬂïÀÂ≤œ?ˇ\vyÜŸ◊Îqu÷√199πäQÏ‡‡†¬¿}>üÙr›n◊~˝Î_K~√.®ô∆  ’IDAT–ÕÎıäÓKáÖ˙ûdLZªdÙ‚qBıûNßU6rÈ$Bî≈§nO•R:ûÈÉAk6õ
xc¯MH]<ÿÇΩ°ÒÿÄs2sA….àyêx◊jµ™pA‘Ã©Påèè¶	⁄öêÖR©dªªªÊp8ÏŸ≥g∂∂∂¶‹≥Îı∏:Î·¯∆7æ±zpp`7oﬁ‡ë#ñ‰p^≠VKRß≈≈EÈô± Qrπ\R´ﬂ∏q√º^Øé\î‰y—=±ââ	âÇŸàÇ©NöQø›∫uK^†µµ5A≥Ÿ¨˛ﬂôô]¶=èÊ^ΩÊ>\Ÿ·pXÍÔ≥≥3ïí K{Ò∏[¬qÏt:ñÀÂlqq—nﬁºi}Ùë‘/[[[∫ò'ìI´T*6;;k>üœ>˘‰·Æ◊„j≠á„ªﬂ˝Ój/î|0¥ÈÈi˘≠ÿ;ùéÕœœ[__üKı^ô>LÚ¥¶¢¶¿∆Åˇâãˇ··°æ,¿$0ÔÅP6õM)E-
íf%ìI´’jâDÏ¯¯¯í∂èÚÚÒõπ√‘¯–`˝~ø2Ä{CÈÄ_‚$@ñlggGÉ–jµjÒx‹&&&Ïø˛ÎøÏËË»‚Ò∏4tÁ∞¡\Ø«’Y«wæÛùUZ‰‰n¡tßL¿J¢—hX©TíÇñ<m„h4™!2–òÛÛs&ißriDäã»&3áD"aììì¬~°_÷ﬂﬂ/µbÖB¡<èÖB!€⁄⁄“∞õí»ÈtZ8	ò¯%,9\éQÓw:YH–jRÊ–ùCU±¥¥$≈Và„„cªsÁéıııY*ï(∆ÎıZµZïüÃÁÛ)‚z=ÆŒz8ﬁ}˜›UóÀ%\PîÅÅ+óÀV´’,ö«„±˝˝}π>ë¢†»Âr
≈]´’‰«°≥Ñ›ù›∂CZà∫LÛ˘ºÕÕÕŸÃÃåJ$[ïJ≈∂∑∑Ì∆ç‚Ç`ÌGÿ∫≥≥£t¥et• Y8V}œº”ÈHUÕîüÓW4µvª≠NXÓ±±1€ﬁﬁ÷]§øøﬂ∆««ÌPà∏°°!\‡gUá-Âz=ÆŒz8û>}∫Í˜˚Uc÷Îui‹òO9ùN€ÿÿ∞ÉÉ!‘òì∏›n)í<x`çFCñà@ †˘ÜÀÂíÊÎıÎ◊*(-H(ƒâ´ö 6¨î5Hî sÜB!]Jiıv:ÛzΩ!@/"ó
&$ój4àçqKÔÌÌY(“Ó>00†{@Ø8ıÙÙTø7_2ñJ5è«£Y‰bÜª„„„
íª^è´≥éˇ˜_≠◊Îí”RŸÀ4$g7ã©Ãòûû∂œ>˚ÃFFF,HlI}çMÅˆ1∆Gö‘¯¡`PŸYÃ'P5c„Ä•xrr"zÆ€Ìñ§à .£®®˜ˆˆ,ã…Õä¿J1üõù	jáb±hŸl÷ Â≤ÕÕÕ…≤èø˝d±XèÇÆ§,Z◊£££Êt:•&ËùÕQ€√rº^è´≥é˝◊]Â>??◊¿b§”iŸB ÖP∑√´pª›644dÖB¡FGGÌ‡‡¿b±òh=gggä6eC;4^¢HäêŒô
ÖÇ’ÎuõôôëLÜ¨‚F£a«««çFE=BÉ∑¥¥§‰œD"!f<DXÏÃÉ
ÖÇ:j8≤ÖÇ%	á√:0)`éâ»Œ‘‘î¢w∞À0”°T¯BivΩWk=˜Ôﬂ_%kãmKƒø¿OÇ¡†DÆ|Ÿ¡`P0.¡hQ#3/A¿‘Vÿm“YÑ¡F É
ñlﬂÄRQÚJµèOå(XıtﬁH*∂ÉÉÀd2ó¢Ö`åt:uß∂∂∂åaëê^%	;99ë=ıh5PoÂrYpQ≤…d“Æ◊„j≠á„€ﬂ˛ˆ*_‰ÙÙ¥ä_|ÒÖÉAAbp53‹#ß	!mß”±ππ9e"ÔÏÏHéÉ•Ç9G4pS"f®ØwwwÂµj∑€öŸ@xeG∆Ÿn∑ïÀº∂∂fff≥≥≥™√ãÚÂc3a«ÏvªóÚú>ÊÛyµóQ>ÖOãº/œÃ¨P(X$—ÉÀ}®€Ì*ı£’jY´’íœòÏãÎı∏:Î·xˇ˝˜W1!‚Pùòò!µ<ãã≈Ã·p(/‹ æúÌÌmîcl£s}â<+vD•ÿ“q`˜ö8…8ÊR	wùËSZ–cccr`%·≥„ÿ4É£‹Z>ü7∑€m"·|mµZ
ÖÑ7sª›÷Èt,ùN+v˙˝˚˜•(≤ΩΩ=K•Räi¬AÃä-„Îı∏ZÎ·x˜›wWŸ›:ùé•R)±+¯†Ïf_ø~mëHDA‡ßßßV´’°v¶C˚-e:;f)'&&d7s≈y∑€ïG´^Ø[<∑rπ,a1®m>7û)†®ÃgêÕŒŒäx
"¶FhkµZUÕjŒ<˘ÒÒ±,<bë$	q(|>ü~éÎı∏ZÎ·¯·∏ö…dlwwWrêb±(`˛˝˚VØ◊≈J‡HÑCª jnéZîÿ|q`æº^ØlX.\.ó.Ω¸>√√√≤Õì’Ì‹ﬂﬂWZ˝——ë ò†ﬁ∞´ìÉ™ªBU,‹0!ÚsPhHKõ–sÓ(–∏ŒŒŒÏ›l6-ç*äa)ˇ}:ù∂H$b◊Îqµ÷√Ò‰…ì’\.'U@2ô¥`0(º◊÷÷ñ˛öÈ;" ÛÛsÌñÑR”∂≈Û√ÃëNà9ÛóììµmÅ–PŒ‡?#Ë ˚LPp;;;À†¯Nß”÷h4tôÅ6õÕ*å$ˆzúºız›ÊÁÁïfÇ∫´G8S±^ØÀÂ˜˚≠R©X$Éá˘¸¸\ U˝Põhçg≥Yª^è´µéÔ|Á;´∑n›c·ˆÌ€r∑f2õòò∞ùùÓ0£•”i+
ä	"úv&ÌM¢à(Ë»D£Qk4ÚÖ√a[XXP»DØÄãÀÂ”Ê¸<DÖBA ‹∑L¯q∑2$§Æ5è«c’j’û?nwÓ‹±››]kµZv˜Ó]a»©Ác±òU´U°’ ◊íÍHË]2ô‘}Ñùì°ÀÂ≤ÉÉïe∏ƒáÜÜÏz=Æ÷z8æˇ˝ÔØ&	¡B«∆∆,ëHàLL∏√9¶€xá0[Rw:≈‡ s9<<T64¢œ©©)©X$ (Ω`N jaÏÚ¥ß,üœÀﬂ≥∏∏(õ~ø}˛˘Á2NﬁºyS_(;<	ò+++í€úüü€∆∆ÜRgp
„°Í’’q…@©F%\î®&NNNDÕ¢ÎuΩWk=Oû<YB≤∞∞†cƒX©Tvç–t:≠ù+XΩ^óLÖ@π\∂x<ÆÑñzΩ.¢R‰>ΩJ§ú†¿FxJÓÔΩ{˜l}}]vvKÍÍ±±1Àd2‘¿¬h4
ÍBJË:,ÛÛÛs;;;ìù÷5H4»L\‘I]·3¿≈ ’íÚ#Z,≥ﬂˇ˛˜ffV*ïîÍ922¢»X—◊Îqµ÷√ÒΩÔ}oïYC>üó}ö8"”Ë<qÃf≥∂¥¥§.ÿ/¬–<x`ˆ·CÖ≥AXä≈bÊÛ˘d„∆ïÍp8¨^Ø+I1ãôﬂÔ∑µµ5¥Ú‰‰Dãï©wêﬁ09R&ÕÃB°êÉAk4ôÓÔÔ€ÏÏ¨ÿÃÃåºMÏÿKKKÍ≤•R)[[[≥ŸŸYÕx¿XCa
ÖB22˛√Eù±èÇNﬂ≠[∑Ï‚‚¬Æ◊„j≠á„È”ß´Ù˙777ıe:ùNyzcsHEÖB⁄≠ËPçèè[•R˘«„ÒÿÛÁœ≠€Ì
jJŸ±∑∑ßÄ[C:/|Gfà4	°´V´6::*R0RûÛÛs{¸¯±ùúúXπ\%ñè^¡È≈≈Ö}Ò≈
á]Q7è€ˆˆ∂	zS.ó•P˚˝¬°ﬂ{ıÍïN
⁄‘ffSSSö	kµZ20ûùùY£—∞Z≠f◊Îqµ÷√Ò/ˇÚ/´tM4¬G'S˘¯¯XªS~∑€m©TJÉπﬁ@ÍX,fg6Àd2‘a[GÄMoŒSàÅ@@ã@~q¶®öÕ¶bô∆∆∆‰†eg%–-ì…ËÁÑ	±ººlcccˆ…'üX__ü›πsGZËDggg∂≥≥#D6sñl6{)rñáÌZΩ^WÍ˘˘π|XÑ"Ä8K•RÚ)]Ø«’Z«∑ø˝ÌULu®í›n∑€ßü~jùN«Ó›ªg’j’ä≈¢-..ö”È‘¥õ mp‡7775KÖBRy√G\[[Sà:…ïàGô= Ô<::;cﬁ‡‡†π›nµõâ∞•5Læ	ºJHmL¬UDØBñD≥Ÿ¥F£aÀÀÀBçÒˇˆ“µNOOÌøˇ˚ø-(X"ùNÀ‹«Ω«„Òÿ∆∆ÜÂÛysπ\Ú<ÌÏÏX$±˛˛~ª^è´µéo~Ûõ´∫»Òín»Ö©~∑€µΩΩ=ÎÎÎ≥©©)1Ûãb∞É÷322bììì∂ºº,„Z≤üQÄ∞Ü˝πÅÁ¥ü)9∏‹Z>ü∑ëëu§ËXa$A%¸ﬂ<ﬂˇÅêz<[YYQ«hppP*¨Ù¿°U*Éè«-ôLjwÎ≈i#≤Òï‹,h¿ÔºÛéÅ◊Îqµ÷√Òoˇˆo´;;;ÇuÓÌÌŸ˙˙∫π›n•g0‘D&S©T¥s`˝&*>")333ffñH$¥H'''Ú7Qˇf2Ôëwºªªkv„∆·¢°¯≤´ñJ%Ÿ“].ó>/â,\‰A(cV§ÌúL&Õ·p»UKH*pf6Ÿl÷NNN§0@û‘n∑-ëHÿ““íà≈@VπÉµûòò∞ÌÌm∂Ø˝Îr‚í4√\Êz=Æ÷zÙ˝¸Á?Ô¬-8??◊óè\¢ƒ5õMª}˚∂ãEk4aWÄ©WØ◊-ì…ÿ´WØÏ…ì'÷ﬂﬂo~ø_Âû'j~¬ÍHÌ§‹ôööRk⁄ÂrÈKÊB^(§#c“Oÿs\≥p'êÏ[≠Vìÿ˘N(R÷ÒÏÏ¨ÌÏÏhG§¡@Ù-ÙëHƒá–kÉÉÉ6==m˚˚˚b≠Û]É§¶ƒ∂f≥i◊Îqµ÷√Òﬁ{Ô≠ˆíÑ∞O◊j5ÀÁÛBìäQ©T§ÃÜÅºÖ§Áä≈¢ïÀeõòò∞˘˘y)ƒ›n∑hFÏÄîﬁÜÜÜ§gCK«ï∫ØØOâÜ–ÑHûûûZ4Y	Ì._Ø◊+Õ"®jZﬂùNGVy8∏l	;@
Ù¸˘sÛzΩ
∞ÛzΩ655%5w&ì[„ÙÙTvçππ9˘µ &_Ø«’ZèˇdDˇ⁄≥{V    IENDÆB`Ç#!/usr/bin/env php
# autogenerated file; do not edit
sudo: false
language: c

addons:
 apt:
  packages:
   - php5-cli
   - php-pear

env:
 matrix:
<?php

$gen = include "./travis/pecl/gen-matrix.php";
$env = $gen([
	"PHP" => ["master"],
	"enable_debug",
	"enable_maintainer_zts",
]);
foreach ($env as $e) {
	printf("  - %s\n", $e);
}

?>

before_script:
 - make -f travis/pecl/Makefile php
 - make -f travis/pecl/Makefile ext PECL=raphf

script:
 - make -f travis/pecl/Makefile test
/*
    +--------------------------------------------------------------------+
    | PECL :: raphf                                                      |
    +--------------------------------------------------------------------+
    | Redistribution and use in source and binary forms, with or without |
    | modification, are permitted provided that the conditions mentioned |
    | in the accompanying LICENSE file are met.                          |
    +--------------------------------------------------------------------+
    | Copyright (c) 2013, Michael Wallner <mike@php.net>                 |
    +--------------------------------------------------------------------+
*/

#ifdef HAVE_CONFIG_H
#	include "config.h"
#endif

#include "php.h"
#include "php_ini.h"
#include "ext/standard/info.h"
#include "php_raphf.h"

#ifndef PHP_RAPHF_TEST
#	define PHP_RAPHF_TEST 0
#endif

struct php_persistent_handle_globals {
	ulong limit;
	HashTable hash;
};

ZEND_BEGIN_MODULE_GLOBALS(raphf)
	struct php_persistent_handle_globals persistent_handle;
ZEND_END_MODULE_GLOBALS(raphf)

#ifdef ZTS
#	define PHP_RAPHF_G ((zend_raphf_globals *) \
		(*((void ***) tsrm_get_ls_cache()))[TSRM_UNSHUFFLE_RSRC_ID(raphf_globals_id)])
#else
#	define PHP_RAPHF_G (&raphf_globals)
#endif

ZEND_DECLARE_MODULE_GLOBALS(raphf)

#ifndef PHP_RAPHF_DEBUG_PHANDLES
#	define PHP_RAPHF_DEBUG_PHANDLES 0
#endif
#if PHP_RAPHF_DEBUG_PHANDLES
#	undef inline
#	define inline
#endif

php_resource_factory_t *php_resource_factory_init(php_resource_factory_t *f,
		php_resource_factory_ops_t *fops, void *data, void (*dtor)(void *data))
{
	if (!f) {
		f = emalloc(sizeof(*f));
	}
	memset(f, 0, sizeof(*f));

	memcpy(&f->fops, fops, sizeof(*fops));

	f->data = data;
	f->dtor = dtor;

	f->refcount = 1;

	return f;
}

unsigned php_resource_factory_addref(php_resource_factory_t *rf)
{
	return ++rf->refcount;
}

void php_resource_factory_dtor(php_resource_factory_t *f)
{
	if (!--f->refcount) {
		if (f->dtor) {
			f->dtor(f->data);
		}
	}
}

void php_resource_factory_free(php_resource_factory_t **f)
{
	if (*f) {
		php_resource_factory_dtor(*f);
		if (!(*f)->refcount) {
			efree(*f);
			*f = NULL;
		}
	}
}

void *php_resource_factory_handle_ctor(php_resource_factory_t *f, void *init_arg)
{
	if (f->fops.ctor) {
		return f->fops.ctor(f->data, init_arg);
	}
	return NULL;
}

void *php_resource_factory_handle_copy(php_resource_factory_t *f, void *handle)
{
	if (f->fops.copy) {
		return f->fops.copy(f->data, handle);
	}
	return NULL;
}

void php_resource_factory_handle_dtor(php_resource_factory_t *f, void *handle)
{
	if (f->fops.dtor) {
		f->fops.dtor(f->data, handle);
	}
}

php_resource_factory_t *php_persistent_handle_resource_factory_init(
		php_resource_factory_t *a, php_persistent_handle_factory_t *pf)
{
	return php_resource_factory_init(a,
			php_persistent_handle_get_resource_factory_ops(), pf,
			(void(*)(void*)) php_persistent_handle_abandon);
}

zend_bool php_resource_factory_is_persistent(php_resource_factory_t *a)
{
	return a->dtor == (void(*)(void *)) php_persistent_handle_abandon;
}

static inline php_persistent_handle_list_t *php_persistent_handle_list_init(
		php_persistent_handle_list_t *list)
{
	if (!list) {
		list = pemalloc(sizeof(*list), 1);
	}
	list->used = 0;
	zend_hash_init(&list->free, 0, NULL, NULL, 1);

	return list;
}

static int php_persistent_handle_apply_stat(zval *p, int argc, va_list argv,
		zend_hash_key *key)
{
	php_persistent_handle_list_t *list = Z_PTR_P(p);
	zval zsubentry, *zentry = va_arg(argv, zval *);

	array_init(&zsubentry);
	add_assoc_long_ex(&zsubentry, ZEND_STRL("used"), list->used);
	add_assoc_long_ex(&zsubentry, ZEND_STRL("free"),
			zend_hash_num_elements(&list->free));
	if (key->key) {
		add_assoc_zval_ex(zentry, key->key->val, key->key->len, &zsubentry);
	} else {
		add_index_zval(zentry, key->h, &zsubentry);
	}
	return ZEND_HASH_APPLY_KEEP;
}

static int php_persistent_handle_apply_statall(zval *p, int argc, va_list argv,
		zend_hash_key *key)
{
	php_persistent_handle_provider_t *provider = Z_PTR_P(p);
	HashTable *ht = va_arg(argv, HashTable *);
	zval zentry;

	array_init(&zentry);

	zend_hash_apply_with_arguments(&provider->list.free,
			php_persistent_handle_apply_stat, 1, &zentry);

	if (key->key) {
		zend_hash_update(ht, key->key, &zentry);
	} else {
		zend_hash_index_update(ht, key->h, &zentry);
	}

	return ZEND_HASH_APPLY_KEEP;
}

static int php_persistent_handle_apply_cleanup_ex(zval *p, void *arg)
{
	php_resource_factory_t *rf = arg;
	void *handle = Z_PTR_P(p);

#if PHP_RAPHF_DEBUG_PHANDLES
	fprintf(stderr, "DESTROY: %p\n", handle);
#endif
	php_resource_factory_handle_dtor(rf, handle);
	return ZEND_HASH_APPLY_REMOVE;
}

static int php_persistent_handle_apply_cleanup(zval *p, void *arg)
{
	php_resource_factory_t *rf = arg;
	php_persistent_handle_list_t *list = Z_PTR_P(p);

	zend_hash_apply_with_argument(&list->free,
			php_persistent_handle_apply_cleanup_ex, rf);
	if (list->used) {
		return ZEND_HASH_APPLY_KEEP;
	}
	zend_hash_destroy(&list->free);
#if PHP_RAPHF_DEBUG_PHANDLES
	fprintf(stderr, "LSTFREE: %p\n", list);
#endif
	pefree(list, 1);
	return ZEND_HASH_APPLY_REMOVE;
}

static inline void php_persistent_handle_list_dtor(
		php_persistent_handle_list_t *list,
		php_persistent_handle_provider_t *provider)
{
#if PHP_RAPHF_DEBUG_PHANDLES
	fprintf(stderr, "LSTDTOR: %p\n", list);
#endif
	zend_hash_apply_with_argument(&list->free,
			php_persistent_handle_apply_cleanup_ex, &provider->rf);
	zend_hash_destroy(&list->free);
}

static inline void php_persistent_handle_list_free(
		php_persistent_handle_list_t **list,
		php_persistent_handle_provider_t *provider)
{
	php_persistent_handle_list_dtor(*list, provider);
#if PHP_RAPHF_DEBUG_PHANDLES
	fprintf(stderr, "LSTFREE: %p\n", *list);
#endif
	pefree(*list, 1);
	*list = NULL;
}

static int php_persistent_handle_list_apply_dtor(zval *p, void *provider)
{
	php_persistent_handle_list_t *list = Z_PTR_P(p);

	php_persistent_handle_list_free(&list, provider );
	ZVAL_PTR(p, NULL);
	return ZEND_HASH_APPLY_REMOVE;
}

static inline php_persistent_handle_list_t *php_persistent_handle_list_find(
		php_persistent_handle_provider_t *provider, zend_string *ident)
{
	php_persistent_handle_list_t *list;
	zval *zlist = zend_symtable_find(&provider->list.free, ident);

	if (zlist && (list = Z_PTR_P(zlist))) {
#if PHP_RAPHF_DEBUG_PHANDLES
		fprintf(stderr, "LSTFIND: %p\n", list);
#endif
		return list;
	}

	if ((list = php_persistent_handle_list_init(NULL))) {
		zval p, *rv;
		zend_string *id;

		ZVAL_PTR(&p, list);
		id = zend_string_init(ident->val, ident->len, 1);
		rv = zend_symtable_update(&provider->list.free, id, &p);
		zend_string_release(id);

		if (rv) {
#if PHP_RAPHF_DEBUG_PHANDLES
			fprintf(stderr, "LSTFIND: %p (new)\n", list);
#endif
			return list;
		}
		php_persistent_handle_list_free(&list, provider);
	}

	return NULL;
}

static int php_persistent_handle_apply_cleanup_all(zval *p, int argc,
		va_list argv, zend_hash_key *key)
{
	php_persistent_handle_provider_t *provider = Z_PTR_P(p);
	zend_string *ident = va_arg(argv, zend_string *);
	php_persistent_handle_list_t *list;

	if (ident && ident->len) {
		if ((list = php_persistent_handle_list_find(provider, ident))) {
			zend_hash_apply_with_argument(&list->free,
					php_persistent_handle_apply_cleanup_ex,
					&provider->rf);
		}
	} else {
		zend_hash_apply_with_argument(&provider->list.free,
				php_persistent_handle_apply_cleanup, &provider->rf);
	}

	return ZEND_HASH_APPLY_KEEP;
}

static void php_persistent_handle_hash_dtor(zval *p)
{
	php_persistent_handle_provider_t *provider = Z_PTR_P(p);

	zend_hash_apply_with_argument(&provider->list.free,
			php_persistent_handle_list_apply_dtor, provider);
	zend_hash_destroy(&provider->list.free);
	php_resource_factory_dtor(&provider->rf);
	pefree(provider, 1);
}

ZEND_RESULT_CODE php_persistent_handle_provide(zend_string *name,
		php_resource_factory_ops_t *fops, void *data, void (*dtor)(void *))
{
	php_persistent_handle_provider_t *provider = pemalloc(sizeof(*provider), 1);

	if (php_persistent_handle_list_init(&provider->list)) {
		if (php_resource_factory_init(&provider->rf, fops, data, dtor)) {
			zval p, *rv;
			zend_string *ns;

#if PHP_RAPHF_DEBUG_PHANDLES
			fprintf(stderr, "PROVIDE: %p %s\n", PHP_RAPHF_G, name_str);
#endif

			ZVAL_PTR(&p, provider);
			ns = zend_string_init(name->val, name->len, 1);
			rv = zend_symtable_update(&PHP_RAPHF_G->persistent_handle.hash, ns, &p);
			zend_string_release(ns);

			if (rv) {
				return SUCCESS;
			}
			php_resource_factory_dtor(&provider->rf);
		}
	}

	return FAILURE;
}


php_persistent_handle_factory_t *php_persistent_handle_concede(
		php_persistent_handle_factory_t *a,
		zend_string *name, zend_string *ident,
		php_persistent_handle_wakeup_t wakeup,
		php_persistent_handle_retire_t retire)
{
	zval *zprovider = zend_symtable_find(&PHP_RAPHF_G->persistent_handle.hash, name);

	if (zprovider) {
		zend_bool free_a = 0;

		if ((free_a = !a)) {
			a = emalloc(sizeof(*a));
		}
		memset(a, 0, sizeof(*a));

		a->provider = Z_PTR_P(zprovider);
		a->ident = zend_string_copy(ident);
		a->wakeup = wakeup;
		a->retire = retire;
		a->free_on_abandon = free_a;
	} else {
		a = NULL;
	}

#if PHP_RAPHF_DEBUG_PHANDLES
	fprintf(stderr, "CONCEDE: %p %p (%s) (%s)\n", PHP_RAPHF_G,
			a ? a->provider : NULL, name->val, ident->val);
#endif

	return a;
}

void php_persistent_handle_abandon(php_persistent_handle_factory_t *a)
{
	zend_bool f = a->free_on_abandon;

#if PHP_RAPHF_DEBUG_PHANDLES
	fprintf(stderr, "ABANDON: %p\n", a->provider);
#endif

	zend_string_release(a->ident);
	memset(a, 0, sizeof(*a));
	if (f) {
		efree(a);
	}
}

void *php_persistent_handle_acquire(php_persistent_handle_factory_t *a, void *init_arg)
{
	int key;
	zval *p;
	zend_ulong index;
	void *handle = NULL;
	php_persistent_handle_list_t *list;

	list = php_persistent_handle_list_find(a->provider, a->ident);
	if (list) {
		zend_hash_internal_pointer_end(&list->free);
		key = zend_hash_get_current_key(&list->free, NULL, &index);
		p = zend_hash_get_current_data(&list->free);
		if (p && HASH_KEY_NON_EXISTENT != key) {
			handle = Z_PTR_P(p);
			if (a->wakeup) {
				a->wakeup(a, &handle);
			}
			zend_hash_index_del(&list->free, index);
		} else {
			handle = php_resource_factory_handle_ctor(&a->provider->rf, init_arg);
		}
#if PHP_RAPHF_DEBUG_PHANDLES
		fprintf(stderr, "CREATED: %p\n", handle);
#endif
		if (handle) {
			++a->provider->list.used;
			++list->used;
		}
	}

	return handle;
}

void *php_persistent_handle_accrete(php_persistent_handle_factory_t *a, void *handle)
{
	void *new_handle = NULL;
	php_persistent_handle_list_t *list;

	new_handle = php_resource_factory_handle_copy(&a->provider->rf, handle);
	if (handle) {
		list = php_persistent_handle_list_find(a->provider, a->ident);
		if (list) {
			++list->used;
		}
		++a->provider->list.used;
	}

	return new_handle;
}

void php_persistent_handle_release(php_persistent_handle_factory_t *a, void *handle)
{
	php_persistent_handle_list_t *list;

	list = php_persistent_handle_list_find(a->provider, a->ident);
	if (list) {
		if (a->provider->list.used >= PHP_RAPHF_G->persistent_handle.limit) {
#if PHP_RAPHF_DEBUG_PHANDLES
			fprintf(stderr, "DESTROY: %p\n", handle);
#endif
			php_resource_factory_handle_dtor(&a->provider->rf, handle);
		} else {
			if (a->retire) {
				a->retire(a, &handle);
			}
			zend_hash_next_index_insert_ptr(&list->free, handle);
		}

		--a->provider->list.used;
		--list->used;
	}
}

void php_persistent_handle_cleanup(zend_string *name, zend_string *ident)
{
	php_persistent_handle_provider_t *provider;
	php_persistent_handle_list_t *list;

	if (name) {
		zval *zprovider = zend_symtable_find(&PHP_RAPHF_G->persistent_handle.hash,
				name);

		if (zprovider && (provider = Z_PTR_P(zprovider))) {
			if (ident) {
				list = php_persistent_handle_list_find(provider, ident);
				if (list) {
					zend_hash_apply_with_argument(&list->free,
							php_persistent_handle_apply_cleanup_ex,
							&provider->rf);
				}
			} else {
				zend_hash_apply_with_argument(&provider->list.free,
						php_persistent_handle_apply_cleanup,
						&provider->rf);
			}
		}
	} else {
		zend_hash_apply_with_arguments(
				&PHP_RAPHF_G->persistent_handle.hash,
				php_persistent_handle_apply_cleanup_all, 1, ident);
	}
}

HashTable *php_persistent_handle_statall(HashTable *ht)
{
	if (zend_hash_num_elements(&PHP_RAPHF_G->persistent_handle.hash)) {
		if (!ht) {
			ALLOC_HASHTABLE(ht);
			zend_hash_init(ht, 0, NULL, ZVAL_PTR_DTOR, 0);
		}
		zend_hash_apply_with_arguments(
				&PHP_RAPHF_G->persistent_handle.hash,
				php_persistent_handle_apply_statall, 1, ht);
	} else if (ht) {
		ht = NULL;
	}

	return ht;
}

static php_resource_factory_ops_t php_persistent_handle_resource_factory_ops = {
	(php_resource_factory_handle_ctor_t) php_persistent_handle_acquire,
	(php_resource_factory_handle_copy_t) php_persistent_handle_accrete,
	(php_resource_factory_handle_dtor_t) php_persistent_handle_release
};

php_resource_factory_ops_t *php_persistent_handle_get_resource_factory_ops(void)
{
	return &php_persistent_handle_resource_factory_ops;
}

ZEND_BEGIN_ARG_INFO_EX(ai_raphf_stat_persistent_handles, 0, 0, 0)
ZEND_END_ARG_INFO();
static PHP_FUNCTION(raphf_stat_persistent_handles)
{
	if (SUCCESS == zend_parse_parameters_none()) {
		object_init(return_value);
		if (php_persistent_handle_statall(HASH_OF(return_value))) {
			return;
		}
		zval_dtor(return_value);
	}
	RETURN_FALSE;
}

ZEND_BEGIN_ARG_INFO_EX(ai_raphf_clean_persistent_handles, 0, 0, 0)
	ZEND_ARG_INFO(0, name)
	ZEND_ARG_INFO(0, ident)
ZEND_END_ARG_INFO();
static PHP_FUNCTION(raphf_clean_persistent_handles)
{
	zend_string *name = NULL, *ident = NULL;

	if (SUCCESS == zend_parse_parameters(ZEND_NUM_ARGS(), "|S!S!", &name, &ident)) {
		php_persistent_handle_cleanup(name, ident);
	}
}

#if PHP_RAPHF_TEST
#	include "php_raphf_test.c"
#endif

static const zend_function_entry raphf_functions[] = {
	ZEND_NS_FENTRY("raphf", stat_persistent_handles,
			ZEND_FN(raphf_stat_persistent_handles),
			ai_raphf_stat_persistent_handles, 0)
	ZEND_NS_FENTRY("raphf", clean_persistent_handles,
			ZEND_FN(raphf_clean_persistent_handles),
			ai_raphf_clean_persistent_handles, 0)
#if PHP_RAPHF_TEST
	ZEND_NS_FENTRY("raphf", provide, ZEND_FN(raphf_provide), NULL, 0)
	ZEND_NS_FENTRY("raphf", conceal, ZEND_FN(raphf_conceal), NULL, 0)
	ZEND_NS_FENTRY("raphf", concede, ZEND_FN(raphf_concede), NULL, 0)
	ZEND_NS_FENTRY("raphf", dispute, ZEND_FN(raphf_dispute), NULL, 0)
	ZEND_NS_FENTRY("raphf", handle_ctor, ZEND_FN(raphf_handle_ctor), NULL, 0)
	ZEND_NS_FENTRY("raphf", handle_copy, ZEND_FN(raphf_handle_copy), NULL, 0)
	ZEND_NS_FENTRY("raphf", handle_dtor, ZEND_FN(raphf_handle_dtor), NULL, 0)
#endif
	{0}
};

PHP_INI_BEGIN()
	STD_PHP_INI_ENTRY("raphf.persistent_handle.limit", "-1", PHP_INI_SYSTEM,
			OnUpdateLong, persistent_handle.limit, zend_raphf_globals,
			raphf_globals)
PHP_INI_END()

static HashTable *php_persistent_handles_global_hash;

static PHP_GINIT_FUNCTION(raphf)
{
	raphf_globals->persistent_handle.limit = -1;

	zend_hash_init(&raphf_globals->persistent_handle.hash, 0, NULL,
			php_persistent_handle_hash_dtor, 1);
	if (php_persistent_handles_global_hash) {
		zend_hash_copy(&raphf_globals->persistent_handle.hash,
				php_persistent_handles_global_hash, NULL);
	}
}

static PHP_GSHUTDOWN_FUNCTION(raphf)
{
	zend_hash_destroy(&raphf_globals->persistent_handle.hash);
}

PHP_MINIT_FUNCTION(raphf)
{
	php_persistent_handles_global_hash = &PHP_RAPHF_G->persistent_handle.hash;

#if PHP_RAPHF_TEST
	PHP_MINIT(raphf_test)(INIT_FUNC_ARGS_PASSTHRU);
#endif

	REGISTER_INI_ENTRIES();
	return SUCCESS;
}

PHP_MSHUTDOWN_FUNCTION(raphf)
{
#if PHP_RAPHF_TEST
	PHP_MSHUTDOWN(raphf_test)(SHUTDOWN_FUNC_ARGS_PASSTHRU);
#endif

	UNREGISTER_INI_ENTRIES();
	php_persistent_handles_global_hash = NULL;
	return SUCCESS;
}

static int php_persistent_handle_apply_info_ex(zval *p, int argc,
		va_list argv, zend_hash_key *key)
{
	php_persistent_handle_list_t *list = Z_PTR_P(p);
	zend_hash_key *super_key = va_arg(argv, zend_hash_key *);
	char used[21], free[21];

	slprintf(used, sizeof(used), "%u", list->used);
	slprintf(free, sizeof(free), "%d", zend_hash_num_elements(&list->free));

	php_info_print_table_row(4, super_key->key->val, key->key->val, used, free);

	return ZEND_HASH_APPLY_KEEP;
}

static int php_persistent_handle_apply_info(zval *p, int argc,
		va_list argv, zend_hash_key *key)
{
	php_persistent_handle_provider_t *provider = Z_PTR_P(p);

	zend_hash_apply_with_arguments(&provider->list.free,
			php_persistent_handle_apply_info_ex, 1, key);

	return ZEND_HASH_APPLY_KEEP;
}

PHP_MINFO_FUNCTION(raphf)
{
	php_info_print_table_start();
	php_info_print_table_header(2,
			"Resource and persistent handle factory support", "enabled");
	php_info_print_table_row(2, "Extension version", PHP_RAPHF_VERSION);
	php_info_print_table_end();

	php_info_print_table_start();
	php_info_print_table_colspan_header(4, "Persistent handles in this "
#ifdef ZTS
			"thread"
#else
			"process"
#endif
	);
	php_info_print_table_header(4, "Provider", "Ident", "Used", "Free");
	zend_hash_apply_with_arguments(
			&PHP_RAPHF_G->persistent_handle.hash,
			php_persistent_handle_apply_info, 0);
	php_info_print_table_end();

	DISPLAY_INI_ENTRIES();
}

zend_module_entry raphf_module_entry = {
	STANDARD_MODULE_HEADER,
	"raphf",
	raphf_functions,
	PHP_MINIT(raphf),
	PHP_MSHUTDOWN(raphf),
	NULL,
	NULL,
	PHP_MINFO(raphf),
	PHP_RAPHF_VERSION,
	ZEND_MODULE_GLOBALS(raphf),
	PHP_GINIT(raphf),
	PHP_GSHUTDOWN(raphf),
	NULL,
	STANDARD_MODULE_PROPERTIES_EX
};
/* }}} */

#ifdef COMPILE_DL_RAPHF
ZEND_GET_MODULE(raphf)
#endif

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * End:
 * vim600: noet sw=4 ts=4 fdm=marker
 * vim<600: noet sw=4 ts=4
 */
/*
    +--------------------------------------------------------------------+
    | PECL :: raphf                                                      |
    +--------------------------------------------------------------------+
    | Redistribution and use in source and binary forms, with or without |
    | modification, are permitted provided that the conditions mentioned |
    | in the accompanying LICENSE file are met.                          |
    +--------------------------------------------------------------------+
    | Copyright (c) 2013, Michael Wallner <mike@php.net>                 |
    +--------------------------------------------------------------------+
*/

#ifndef PHP_RAPHF_API_H
#define PHP_RAPHF_API_H

#include "php_raphf.h"

/**
 * A resource constructor.
 *
 * @param opaque is the \a data from php_persistent_handle_provide()
 * @param init_arg is the \a init_arg from php_resource_factory_init()
 * @return the created (persistent) handle
 */
typedef void *(*php_resource_factory_handle_ctor_t)(void *opaque, void *init_arg);

/**
 * The copy constructor of a resource.
 *
 * @param opaque the factory's data
 * @param handle the (persistent) handle to copy
 */
typedef void *(*php_resource_factory_handle_copy_t)(void *opaque, void *handle);

/**
 * The destructor of a resource.
 *
 * @param opaque the factory's data
 * @param handle the handle to destroy
 */
typedef void (*php_resource_factory_handle_dtor_t)(void *opaque, void *handle);

/**
 * The resource ops consisting of a ctor, a copy ctor and a dtor.
 *
 * Define this ops and register them with php_persistent_handle_provide()
 * in MINIT.
 */
typedef struct php_resource_factory_ops {
	/** The resource constructor */
	php_resource_factory_handle_ctor_t ctor;
	/** The resource's copy constructor */
	php_resource_factory_handle_copy_t copy;
	/** The resource's destructor */
	php_resource_factory_handle_dtor_t dtor;
} php_resource_factory_ops_t;

/**
 * The resource factory.
 */
typedef struct php_resource_factory {
	/** The resource ops */
	php_resource_factory_ops_t fops;
	/** Opaque user data */
	void *data;
	/** User data destructor */
	void (*dtor)(void *data);
	/** How often this factory is referenced */
	unsigned refcount;
} php_resource_factory_t;

/**
 * Initialize a resource factory.
 *
 * If you register a \a dtor for a resource factory used with a persistent
 * handle provider, be sure to call php_persistent_handle_cleanup() for your
 * registered provider in MSHUTDOWN, else the dtor will point to no longer
 * available memory if the extension has already been unloaded.
 *
 * @param f the factory to initialize; if NULL allocated on the heap
 * @param fops the resource ops to assign to the factory
 * @param data opaque user data; may be NULL
 * @param dtor a destructor for the data; may be NULL
 * @return \a f or an allocated resource factory
 */
PHP_RAPHF_API php_resource_factory_t *php_resource_factory_init(
		php_resource_factory_t *f, php_resource_factory_ops_t *fops, void *data,
		void (*dtor)(void *data));

/**
 * Increase the refcount of the resource factory.
 *
 * @param rf the resource factory
 * @return the new refcount
 */
PHP_RAPHF_API unsigned php_resource_factory_addref(php_resource_factory_t *rf);

/**
 * Destroy the resource factory.
 *
 * If the factory's refcount reaches 0, the \a dtor for \a data is called.
 *
 * @param f the resource factory
 */
PHP_RAPHF_API void php_resource_factory_dtor(php_resource_factory_t *f);

/**
 * Destroy and free the resource factory.
 *
 * Calls php_resource_factory_dtor() and frees \a f if the factory's refcount
 * reached 0.
 *
 * @param f the resource factory
 */
PHP_RAPHF_API void php_resource_factory_free(php_resource_factory_t **f);

/**
 * Construct a resource by the resource factory \a f
 *
 * @param f the resource factory
 * @param init_arg for the resource constructor
 * @return the new resource
 */
PHP_RAPHF_API void *php_resource_factory_handle_ctor(php_resource_factory_t *f,
		void *init_arg);

/**
 * Create a copy of the resource \a handle
 *
 * @param f the resource factory
 * @param handle the resource to copy
 * @return the copy
 */
PHP_RAPHF_API void *php_resource_factory_handle_copy(php_resource_factory_t *f,
		void *handle);

/**
 * Destroy (and free) the resource
 *
 * @param f the resource factory
 * @param handle the resource to destroy
 */
PHP_RAPHF_API void php_resource_factory_handle_dtor(php_resource_factory_t *f,
		void *handle);

/**
 * Persistent handles storage
 */
typedef struct php_persistent_handle_list {
	/** Storage of free resources */
	HashTable free;
	/** Count of acquired resources */
	ulong used;
} php_persistent_handle_list_t;

/**
 * Definition of a persistent handle provider.
 * Holds a resource factory an a persistent handle list.
 */
typedef struct php_persistent_handle_provider {
	 /**
	  * The list of free handles.
	  * Hash of "ident" => array(handles) entries. Persistent handles are
	  * acquired out of this list.
	  */
	php_persistent_handle_list_t list;

	/**
	 * The resource factory.
	 * New handles are created by this factory.
	 */
	php_resource_factory_t rf;
} php_persistent_handle_provider_t;

typedef struct php_persistent_handle_factory php_persistent_handle_factory_t;

/**
 * Wakeup the persistent handle on re-acquisition.
 */
typedef void (*php_persistent_handle_wakeup_t)(
		php_persistent_handle_factory_t *f, void **handle);
/**
 * Retire the persistent handle on release.
 */
typedef void (*php_persistent_handle_retire_t)(
		php_persistent_handle_factory_t *f, void **handle);

/**
 * Definition of a persistent handle factory.
 *
 * php_persistent_handle_concede() will return a pointer to a
 * php_persistent_handle_factory if a provider for the \a name has
 * been registered with php_persistent_handle_provide().
 */
struct php_persistent_handle_factory {
	/** The persistent handle provider */
	php_persistent_handle_provider_t *provider;
	/** The persistent handle wakeup routine; may be NULL */
	php_persistent_handle_wakeup_t wakeup;
	/** The persistent handle retire routine; may be NULL */
	php_persistent_handle_retire_t retire;

	/** The ident for which this factory manages resources */
	zend_string *ident;

	/** Whether it has to be free'd on php_persistent_handle_abandon() */
	unsigned free_on_abandon:1;
};

/**
 * Register a persistent handle provider in MINIT.
 *
 * Registers a factory provider for \a name_str with \a fops resource factory
 * ops. Call this in your MINIT.
 *
 * A php_resource_factory will be created with \a fops, \a data and \a dtor
 * and will be stored together with a php_persistent_handle_list in the global
 * raphf hash.
 *
 * A php_persistent_handle_factory can then be retrieved by
 * php_persistent_handle_concede() at runtime.
 *
 * @param name the provider name, e.g. "http\Client\Curl"
 * @param fops the resource factory ops
 * @param data opaque user data
 * @param dtor \a data destructor
 * @return SUCCESS/FAILURE
 */
PHP_RAPHF_API ZEND_RESULT_CODE php_persistent_handle_provide(
		zend_string *name, php_resource_factory_ops_t *fops,
		void *data, void (*dtor)(void *));

/**
 * Retrieve a persistent handle factory at runtime.
 *
 * If a persistent handle provider has been registered for \a name, a new
 * php_persistent_handle_factory creating resources in the \a ident
 * namespace will be constructed.
 *
 * The wakeup routine \a wakeup and the retire routine \a retire will be
 * assigned to the new php_persistent_handle_factory.
 *
 * @param a pointer to a factory; allocated on the heap if NULL
 * @param name the provider name, e.g. "http\Client\Curl"
 * @param ident the subsidiary namespace, e.g. "php.net:80"
 * @param wakeup any persistent handle wakeup routine
 * @param retire any persistent handle retire routine
 * @return \a a or an allocated persistent handle factory
 */
PHP_RAPHF_API php_persistent_handle_factory_t *php_persistent_handle_concede(
		php_persistent_handle_factory_t *a,
		zend_string *name, zend_string *ident,
		php_persistent_handle_wakeup_t wakeup,
		php_persistent_handle_retire_t retire);

/**
 * Abandon the persistent handle factory.
 *
 * Destroy a php_persistent_handle_factory created by
 * php_persistent_handle_concede(). If the memory for the factory was allocated,
 * it will automatically be free'd.
 *
 * @param a the persistent handle factory to destroy
 */
PHP_RAPHF_API void php_persistent_handle_abandon(
		php_persistent_handle_factory_t *a);

/**
 * Acquire a persistent handle.
 *
 * That is, either re-use a resource from the free list or create a new handle.
 *
 * If a handle is acquired from the free list, the
 * php_persistent_handle_factory::wakeup callback will be executed for that
 * handle.
 *
 * @param a the persistent handle factory
 * @param init_arg the \a init_arg for php_resource_factory_handle_ctor()
 * @return the acquired resource
 */
PHP_RAPHF_API void *php_persistent_handle_acquire(
		php_persistent_handle_factory_t *a, void *init_arg);

/**
 * Release a persistent handle.
 *
 * That is, either put it back into the free list for later re-use or clean it
 * up with php_resource_factory_handle_dtor().
 *
 * If a handle is put back into the free list, the
 * php_persistent_handle_factory::retire callback will be executed for that
 * handle.
 *
 * @param a the persistent handle factory
 * @param handle the handle to release
 */
PHP_RAPHF_API void php_persistent_handle_release(
		php_persistent_handle_factory_t *a, void *handle);

/**
 * Copy a persistent handle.
 *
 * Let the underlying resource factory copy the \a handle.
 *
 * @param a the persistent handle factory
 * @param handle the resource to accrete
 */
PHP_RAPHF_API void *php_persistent_handle_accrete(
		php_persistent_handle_factory_t *a, void *handle);

/**
 * Retrieve persistent handle resource factory ops.
 *
 * These ops can be used to mask a persistent handle factory as
 * resource factory itself, so you can transparently use the
 * resource factory API, both for persistent and non-persistent
 * ressources.
 *
 * Example:
 * \code{.c}
 * php_resource_factory_t *create_my_rf(zend_string *persistent_id)
 * {
 *     php_resource_factory_t *rf;
 *
 *     if (persistent_id) {
 *         php_persistent_handle_factory_t *pf;
 *         php_resource_factory_ops_t *ops;
 *         zend_string *ns = zend_string_init("my", 2, 1);
 *
 *         ops = php_persistent_handle_get_resource_factory_ops();
 *         pf = php_persistent_handle_concede(NULL, ns, persistent_id, NULL, NULL);
 *         rf = php_persistent_handle_resource_factory_init(NULL, pf);
 *         zend_string_release(ns);
 *     } else {
 *         rf = php_resource_factory_init(NULL, &myops, NULL, NULL);
 *     }
 *     return rf;
 * }
 * \endcode
 */
PHP_RAPHF_API php_resource_factory_ops_t *
php_persistent_handle_get_resource_factory_ops(void);

/**
 * Create a resource factory for persistent handles.
 *
 * This will create a resource factory with persistent handle ops, which wraps
 * the provided reource factory \a pf.
 *
 * @param a the persistent handle resource factory to initialize
 * @param pf the resource factory to wrap
 */
PHP_RAPHF_API php_resource_factory_t *
php_persistent_handle_resource_factory_init(php_resource_factory_t *a,
		php_persistent_handle_factory_t *pf);

/**
 * Check whether a resource factory is a persistent handle resource factory.
 *
 * @param a the resource factory to check
 */
PHP_RAPHF_API zend_bool php_resource_factory_is_persistent(
		php_resource_factory_t *a);

/**
 * Clean persistent handles up.
 *
 * Destroy persistent handles of provider \a name and in subsidiary
 * namespace \a ident.
 *
 * If \a name is NULL, all persistent handles of all providers with a
 * matching \a ident will be cleaned up.
 *
 * If \a identr is NULL all persistent handles of the provider will be
 * cleaned up.
 *
 * Ergo, if both, \a name and \a ident are NULL, then all
 * persistent handles will be cleaned up.
 *
 * You must call this in MSHUTDOWN, if your resource factory ops hold a
 * registered php_resource_factory::dtor, else the dtor will point to
 * memory not any more available if the extension has already been unloaded.
 *
 * @param name the provider name; may be NULL
 * @param ident the subsidiary namespace name; may be NULL
 */
PHP_RAPHF_API void php_persistent_handle_cleanup(zend_string *name,
		zend_string *ident);

/**
 * Retrieve statistics about the current process/thread's persistent handles.
 *
 * @return a HashTable like:
 * \code
 *     [
 *         "name" => [
 *             "ident" => [
 *                 "used" => 1,
 *                 "free" => 0,
 *             ]
 *         ]
 *     ]
 * \endcode
 */
PHP_RAPHF_API HashTable *php_persistent_handle_statall(HashTable *ht);

#endif	/* PHP_RAPHF_API_H */


/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * End:
 * vim600: noet sw=4 ts=4 fdm=marker
 * vim<600: noet sw=4 ts=4
 */
--TEST--
pecl/http-v2 - general and stat
--SKIPIF--
<?php
if (!extension_loaded("http")) {
	die("skip pecl/http needed");
}
if (!class_exists("http\\Client", false)) {
	die("skip pecl/http-v2 with curl support needed");
}
?>
--FILE--
<?php
echo "Test\n";

$h = (array) raphf\stat_persistent_handles();
var_dump(array_intersect_key($h, array_flip(preg_grep("/^http/", array_keys($h)))));

$c = new http\Client("curl", "php.net:80");
do {
	$c->enqueue(new http\Client\Request("GET", "http://php.net"));
} while (count($c) < 3);

$h = (array) raphf\stat_persistent_handles();
var_dump(array_intersect_key($h, array_flip(preg_grep("/^http/", array_keys($h)))));

unset($c);

$h = (array) raphf\stat_persistent_handles();
var_dump(array_intersect_key($h, array_flip(preg_grep("/^http/", array_keys($h)))));

?>
Done
--EXPECTF--
Test
array(2) {
  ["http\Client\Curl"]=>
  array(0) {
  }
  ["http\Client\Curl\Request"]=>
  array(0) {
  }
}
array(2) {
  ["http\Client\Curl"]=>
  array(1) {
    ["php.net:80"]=>
    array(2) {
      ["used"]=>
      int(1)
      ["free"]=>
      int(0)
    }
  }
  ["http\Client\Curl\Request"]=>
  array(1) {
    ["php.net:80"]=>
    array(2) {
      ["used"]=>
      int(3)
      ["free"]=>
      int(0)
    }
  }
}
array(2) {
  ["http\Client\Curl"]=>
  array(1) {
    ["php.net:80"]=>
    array(2) {
      ["used"]=>
      int(0)
      ["free"]=>
      int(1)
    }
  }
  ["http\Client\Curl\Request"]=>
  array(1) {
    ["php.net:80"]=>
    array(2) {
      ["used"]=>
      int(0)
      ["free"]=>
      int(3)
    }
  }
}
Done
--TEST--
pecl/http-v2 - clean with name and id
--SKIPIF--
<?php
if (!extension_loaded("http")) {
	die("skip pecl/http needed");
}
if (!class_exists("http\\Client", false)) {
	die("skip pecl/http-v2 with curl support needed");
}
?>
--FILE--
<?php
echo "Test\n";

$c = new http\Client("curl", "php.net:80");
do {
	$c->enqueue(new http\Client\Request("GET", "http://php.net"));
} while (count($c) < 3);

unset($c);

$h = (array) raphf\stat_persistent_handles();
var_dump(array_intersect_key($h, array_flip(preg_grep("/^http/", array_keys($h)))));


raphf\clean_persistent_handles("http\\Client\\Curl");
raphf\clean_persistent_handles("http\\Client\\Curl\\Request", "php.net:80");

$h = (array) raphf\stat_persistent_handles();
var_dump(array_intersect_key($h, array_flip(preg_grep("/^http/", array_keys($h)))));

?>
Done
--EXPECTF--
Test
array(2) {
  ["http\Client\Curl"]=>
  array(1) {
    ["php.net:80"]=>
    array(2) {
      ["used"]=>
      int(0)
      ["free"]=>
      int(1)
    }
  }
  ["http\Client\Curl\Request"]=>
  array(1) {
    ["php.net:80"]=>
    array(2) {
      ["used"]=>
      int(0)
      ["free"]=>
      int(3)
    }
  }
}
array(2) {
  ["http\Client\Curl"]=>
  array(0) {
  }
  ["http\Client\Curl\Request"]=>
  array(1) {
    ["php.net:80"]=>
    array(2) {
      ["used"]=>
      int(0)
      ["free"]=>
      int(0)
    }
  }
}
Done
--TEST--
pecl/http-v2 - clean with id only
--SKIPIF--
<?php
if (!extension_loaded("http")) {
	die("skip pecl/http needed");
}
if (!class_exists("http\\Client", false)) {
	die("skip pecl/http-v2 with curl support needed");
}
?>
--FILE--
<?php
echo "Test\n";

$c = new http\Client("curl", "php.net:80");
do {
	$c->enqueue(new http\Client\Request("GET", "http://php.net"));
} while (count($c) < 3);

unset($c);

$h = (array) raphf\stat_persistent_handles();
var_dump(array_intersect_key($h, array_flip(preg_grep("/^http/", array_keys($h)))));

raphf\clean_persistent_handles(null, "php.net:80");

$h = (array) raphf\stat_persistent_handles();
var_dump(array_intersect_key($h, array_flip(preg_grep("/^http/", array_keys($h)))));

?>
Done
--EXPECTF--
Test
array(2) {
  ["http\Client\Curl"]=>
  array(1) {
    ["php.net:80"]=>
    array(2) {
      ["used"]=>
      int(0)
      ["free"]=>
      int(1)
    }
  }
  ["http\Client\Curl\Request"]=>
  array(1) {
    ["php.net:80"]=>
    array(2) {
      ["used"]=>
      int(0)
      ["free"]=>
      int(3)
    }
  }
}
array(2) {
  ["http\Client\Curl"]=>
  array(1) {
    ["php.net:80"]=>
    array(2) {
      ["used"]=>
      int(0)
      ["free"]=>
      int(0)
    }
  }
  ["http\Client\Curl\Request"]=>
  array(1) {
    ["php.net:80"]=>
    array(2) {
      ["used"]=>
      int(0)
      ["free"]=>
      int(0)
    }
  }
}
Done
--TEST--
pecl/http-v2 - partial clean
--SKIPIF--
<?php
if (!extension_loaded("http")) {
	die("skip pecl/http needed");
}
if (!class_exists("http\\Client", false)) {
	die("skip pecl/http-v2 with curl support needed");
}
?>
--FILE--
<?php
echo "Test\n";

$h = (array) raphf\stat_persistent_handles();
var_dump(array_intersect_key($h, array_flip(preg_grep("/^http/", array_keys($h)))));

$c = new http\Client("curl", "php.net:80");
$c2 = new http\Client("curl", "php.net:80");
do {
	$c->enqueue(new http\Client\Request("GET", "http://php.net"));
	$c2->enqueue(new http\Client\Request("GET", "http://php.net"));
} while (count($c) < 3);

$h = (array) raphf\stat_persistent_handles();
var_dump(array_intersect_key($h, array_flip(preg_grep("/^http/", array_keys($h)))));

unset($c);

$h = (array) raphf\stat_persistent_handles();
var_dump(array_intersect_key($h, array_flip(preg_grep("/^http/", array_keys($h)))));

raphf\clean_persistent_handles();

$h = (array) raphf\stat_persistent_handles();
var_dump(array_intersect_key($h, array_flip(preg_grep("/^http/", array_keys($h)))));

?>
Done
--EXPECTF--
Test
array(2) {
  ["http\Client\Curl"]=>
  array(0) {
  }
  ["http\Client\Curl\Request"]=>
  array(0) {
  }
}
array(2) {
  ["http\Client\Curl"]=>
  array(1) {
    ["php.net:80"]=>
    array(2) {
      ["used"]=>
      int(2)
      ["free"]=>
      int(0)
    }
  }
  ["http\Client\Curl\Request"]=>
  array(1) {
    ["php.net:80"]=>
    array(2) {
      ["used"]=>
      int(6)
      ["free"]=>
      int(0)
    }
  }
}
array(2) {
  ["http\Client\Curl"]=>
  array(1) {
    ["php.net:80"]=>
    array(2) {
      ["used"]=>
      int(1)
      ["free"]=>
      int(1)
    }
  }
  ["http\Client\Curl\Request"]=>
  array(1) {
    ["php.net:80"]=>
    array(2) {
      ["used"]=>
      int(3)
      ["free"]=>
      int(3)
    }
  }
}
array(2) {
  ["http\Client\Curl"]=>
  array(1) {
    ["php.net:80"]=>
    array(2) {
      ["used"]=>
      int(1)
      ["free"]=>
      int(0)
    }
  }
  ["http\Client\Curl\Request"]=>
  array(1) {
    ["php.net:80"]=>
    array(2) {
      ["used"]=>
      int(3)
      ["free"]=>
      int(0)
    }
  }
}
Done
--TEST--
raphf test
--SKIPIF--
<?php
if (!extension_loaded("raphf")) {
	die("skip need ext/raphf");
}
if (!defined("RAPHF_TEST")) {
	die("skip need RAPHF_TEST defined (-DPHP_RAPHF_TEST=1)");
}
?>
--INI--
raphf.persistent_handle.limit=0
--FILE--
<?php

function dumper($id) {
	return function() use ($id) {
		echo "### back '$id':\n";
		for ($i=0; $i<func_num_args(); ++$i) {
			echo "#### arg $i: ";
			var_dump(func_get_arg($i));
		}
		/* relay arguments back */
		return func_get_args();
	};
}

echo "## call provide:\n";
var_dump(raphf\provide("test",dumper("ctor"),dumper("copy"),dumper("dtor"),"data value",dumper("data_dtor")));

echo "## call concede:\n";
var_dump($rf = raphf\concede("test","1"));

echo "## call handle_ctor:\n";
var_dump($h = raphf\handle_ctor($rf, 1));

echo "## call handle_copy:\n";
var_dump($h2 = raphf\handle_copy($rf, $h));
var_dump(raphf\stat_persistent_handles());

echo "## call handle_dtor:\n";
var_dump(raphf\handle_dtor($rf, $h));
var_dump(raphf\stat_persistent_handles());

echo "## call handle_dtor:\n";
var_dump(raphf\handle_dtor($rf, $h2));
var_dump(raphf\stat_persistent_handles());

echo "## cleanup:\n";
var_dump(raphf\dispute($rf), $rf);
var_dump(raphf\conceal("test"));
var_dump(raphf\stat_persistent_handles());

?>
--EXPECTF--
## call provide:
bool(true)
## call concede:
resource(4) of type (raphf_user)
## call handle_ctor:
### back 'ctor':
#### arg 0: string(10) "data value"
#### arg 1: int(1)
array(2) {
  [0]=>
  string(10) "data value"
  [1]=>
  int(1)
}
## call handle_copy:
### back 'copy':
#### arg 0: string(10) "data value"
#### arg 1: array(2) {
  [0]=>
  string(10) "data value"
  [1]=>
  int(1)
}
array(2) {
  [0]=>
  string(10) "data value"
  [1]=>
  array(2) {
    [0]=>
    string(10) "data value"
    [1]=>
    int(1)
  }
}
object(stdClass)#%d (1) {
  ["test"]=>
  array(1) {
    [1]=>
    array(2) {
      ["used"]=>
      int(2)
      ["free"]=>
      int(0)
    }
  }
}
## call handle_dtor:
### back 'dtor':
#### arg 0: string(10) "data value"
#### arg 1: array(2) {
  [0]=>
  string(10) "data value"
  [1]=>
  int(1)
}
NULL
object(stdClass)#%d (1) {
  ["test"]=>
  array(1) {
    [1]=>
    array(2) {
      ["used"]=>
      int(1)
      ["free"]=>
      int(0)
    }
  }
}
## call handle_dtor:
### back 'dtor':
#### arg 0: string(10) "data value"
#### arg 1: array(2) {
  [0]=>
  string(10) "data value"
  [1]=>
  array(2) {
    [0]=>
    string(10) "data value"
    [1]=>
    int(1)
  }
}
NULL
object(stdClass)#%d (1) {
  ["test"]=>
  array(1) {
    [1]=>
    array(2) {
      ["used"]=>
      int(0)
      ["free"]=>
      int(0)
    }
  }
}
## cleanup:
bool(true)
resource(4) of type (Unknown)
### back 'data_dtor':
#### arg 0: string(10) "data value"
bool(true)
bool(false)
"õ
¨≈T9G 7≠‚¸çè©˝O   GBMB